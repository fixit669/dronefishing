<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>×”×¨×—×¤× ×™×¡×˜×™× - ×ª× ××™ ×“×™×’ ×‘×›×£ | Drone Fishing Conditions</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0e1a;
            color: #e2e8f0;
            padding: 0;
            margin: 0;
            min-height: 100vh;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 30px 20px;
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            border-bottom: 1px solid rgba(100, 116, 139, 0.2);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        h1 {
            font-size: 2.2em;
            margin-bottom: 12px;
            font-weight: 700;
            background: linear-gradient(135deg, #60a5fa 0%, #3b82f6 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            font-size: 1em;
            color: #94a3b8;
            font-weight: 400;
        }

        .score-container {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            padding: 40px;
            border-radius: 16px;
            text-align: center;
            margin-bottom: 30px;
            border: 1px solid rgba(100, 116, 139, 0.3);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
            position: relative;
            overflow: hidden;
        }

        .score-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #3b82f6 0%, #60a5fa 50%, #3b82f6 100%);
            animation: shimmer 3s ease-in-out infinite;
        }

        @keyframes shimmer {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.5; }
            50% { transform: scale(1.1); opacity: 0.3; }
        }

        .score-value {
            font-size: 4.5em;
            font-weight: 700;
            margin: 20px 0;
            position: relative;
            z-index: 1;
            letter-spacing: -2px;
        }

        .score-label {
            font-size: 1.1em;
            color: #94a3b8;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-weight: 600;
            position: relative;
            z-index: 1;
        }

        .status-text {
            font-size: 1.5em;
            margin-top: 15px;
            font-weight: 600;
            position: relative;
            z-index: 1;
        }

        .data-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }

        .data-card {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            border: 1px solid rgba(100, 116, 139, 0.3);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
        }

        .data-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
            border-color: rgba(100, 116, 139, 0.5);
        }

        .card-title {
            font-size: 1em;
            margin-bottom: 12px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(100, 116, 139, 0.2);
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
            color: #cbd5e1;
        }

        .card-icon {
            font-size: 1.4em;
        }

        .card-content {
            font-size: 1.8em;
            font-weight: 700;
            margin: 15px 0;
            text-align: center;
            color: #f1f5f9;
        }

        .card-details {
            font-size: 0.85em;
            color: #94a3b8;
            line-height: 1.5;
        }

        .quality-indicator {
            display: inline-block;
            padding: 6px 14px;
            border-radius: 6px;
            font-size: 0.75em;
            font-weight: 600;
            margin-top: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .excellent { 
            background: rgba(16, 185, 129, 0.2);
            color: #10b981;
            border: 1px solid rgba(16, 185, 129, 0.3);
        }
        .good { 
            background: rgba(59, 130, 246, 0.2);
            color: #3b82f6;
            border: 1px solid rgba(59, 130, 246, 0.3);
        }
        .moderate { 
            background: rgba(245, 158, 11, 0.2);
            color: #f59e0b;
            border: 1px solid rgba(245, 158, 11, 0.3);
        }
        .poor { 
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
            border: 1px solid rgba(239, 68, 68, 0.3);
        }

        .update-time {
            text-align: center;
            margin-top: 30px;
            padding: 15px;
            background: #1e293b;
            border-radius: 8px;
            font-size: 0.85em;
            color: #94a3b8;
            border: 1px solid rgba(100, 116, 139, 0.2);
        }

        .loading {
            text-align: center;
            padding: 40px;
            font-size: 1.2em;
        }

        .error {
            background: rgba(239, 68, 68, 0.15);
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            border-left: 3px solid #ef4444;
            color: #fca5a5;
        }

        .location-info {
            background: #1e293b;
            padding: 16px;
            border-radius: 12px;
            margin-bottom: 20px;
            text-align: center;
            font-size: 0.9em;
            border: 1px solid rgba(100, 116, 139, 0.2);
            color: #cbd5e1;
        }

        .location-info a {
            color: #60a5fa;
            text-decoration: none;
            transition: color 0.2s;
        }

        .location-info a:hover {
            color: #93c5fd;
        }

        @media (max-width: 768px) {
            body {
                padding: 5px;
            }
            
            h1 { 
                font-size: 1.5em; 
            }
            
            .subtitle {
                font-size: 0.8em;
            }
            
            .score-value { 
                font-size: 2.8em; 
            }
            
            .status-text {
                font-size: 1em;
            }
            
            .data-grid { 
                grid-template-columns: repeat(2, 1fr);
                gap: 8px;
            }
            
            .card-title {
                font-size: 0.9em;
            }
            
            .card-content {
                font-size: 1.2em;
            }
            
            .card-details {
                font-size: 0.75em;
            }
            
            header {
                padding: 10px;
                margin-bottom: 10px;
            }
            
            .location-info {
                font-size: 0.75em;
                padding: 10px;
            }
        }

        @media (max-width: 480px) {
            .card-content {
                font-size: 1.1em;
            }
            
            .card-details {
                font-size: 0.7em;
            }
            
            .direction-arrow {
                width: 45px;
                height: 45px;
            }
            
            .moon-visual {
                width: 60px;
                height: 60px;
            }
        }

        @media (min-width: 769px) {
            .data-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        .refresh-btn {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            border: none;
            color: white;
            padding: 12px 28px;
            border-radius: 8px;
            font-size: 0.95em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 15px;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        }

        .refresh-btn:hover {
            background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
            transform: translateY(-1px);
            box-shadow: 0 6px 16px rgba(59, 130, 246, 0.4);
        }

        .location-selector {
            margin: 15px 0 10px 0;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            flex-wrap: wrap;
        }

        .location-selector label {
            font-size: 0.95em;
            font-weight: 600;
            color: #cbd5e1;
        }

        .location-dropdown {
            background: #0f172a;
            border: 1px solid rgba(100, 116, 139, 0.3);
            color: #e2e8f0;
            padding: 10px 16px;
            border-radius: 8px;
            font-size: 0.95em;
            cursor: pointer;
            transition: all 0.3s;
            min-width: 200px;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        .location-dropdown:hover {
            background: #1e293b;
            border-color: rgba(100, 116, 139, 0.5);
        }

        .location-dropdown:focus {
            outline: none;
            background: #1e293b;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .location-dropdown option {
            background: #0f172a;
            color: #e2e8f0;
            padding: 10px;
        }

        @media (max-width: 480px) {
            .location-selector {
                flex-direction: column;
                gap: 8px;
            }
            
            .location-dropdown {
                min-width: 180px;
                font-size: 0.9em;
                padding: 8px 12px;
            }
        }

        .moon-phase-icon {
            font-size: 3em;
            margin: 10px 0;
        }

        .direction-arrow {
            display: inline-block;
            width: 50px;
            height: 50px;
            margin: 8px auto;
            position: relative;
        }

        .arrow-svg {
            width: 100%;
            height: 100%;
            filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3));
        }

        .direction-label {
            text-align: center;
            font-size: 0.85em;
            font-weight: bold;
            margin-top: 3px;
            color: #60a5fa;
        }

        .direction-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 8px 0;
        }

        .moon-visual {
            width: 65px;
            height: 65px;
            margin: 10px auto;
            position: relative;
            background: #1a1a2e;
            border-radius: 50%;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
            overflow: hidden;
        }

        .moon-circle {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            position: relative;
            background: linear-gradient(90deg, #1a1a2e 50%, #f0f0f0 50%);
        }

        .moon-overlay {
            position: absolute;
            top: 0;
            width: 50%;
            height: 100%;
            background: #f0f0f0;
            border-radius: 50%;
        }

        .moon-shadow {
            position: absolute;
            top: 0;
            width: 50%;
            height: 100%;
            background: #1a1a2e;
            border-radius: 50%;
        }

        .time-info {
            font-size: 0.75em;
            margin-top: 5px;
            line-height: 1.5;
        }

        .wind-card {
            grid-column: span 2;
        }

        .wave-card {
            grid-column: span 2;
        }

        .cloud-card {
            grid-column: span 2;
        }

        .wind-current {
            border-bottom: 1px solid rgba(255,255,255,0.2);
            padding-bottom: 10px;
            margin-bottom: 10px;
        }

        .wave-current {
            border-bottom: 1px solid rgba(255,255,255,0.2);
            padding-bottom: 10px;
            margin-bottom: 10px;
        }

        .cloud-current {
            border-bottom: 1px solid rgba(100, 116, 139, 0.2);
            padding-bottom: 10px;
            margin-bottom: 10px;
        }

        .catch-reports-card {
            grid-column: span 2;
        }

        .catch-method-selector {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid rgba(100, 116, 139, 0.2);
        }

        .method-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            padding: 16px 12px;
            background: rgba(100, 116, 139, 0.1);
            border: 2px solid rgba(100, 116, 139, 0.2);
            border-radius: 10px;
            color: #94a3b8;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.9em;
            font-weight: 600;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        .method-btn:hover {
            background: rgba(100, 116, 139, 0.2);
            border-color: rgba(100, 116, 139, 0.4);
            color: #cbd5e1;
            transform: translateY(-2px);
        }

        .method-btn.active {
            background: rgba(59, 130, 246, 0.15);
            border-color: #3b82f6;
            color: #60a5fa;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .method-icon {
            font-size: 1.8em;
        }

        .catch-reports-tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 20px;
            border-bottom: 1px solid rgba(100, 116, 139, 0.2);
            padding-bottom: 0;
        }

        .catch-tab {
            background: transparent;
            border: none;
            color: #94a3b8;
            padding: 10px 20px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 600;
            border-bottom: 2px solid transparent;
            transition: all 0.3s;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        .catch-tab:hover {
            color: #cbd5e1;
        }

        .catch-tab.active {
            color: #60a5fa;
            border-bottom-color: #60a5fa;
        }

        .catch-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }

        .catch-stat-item {
            text-align: center;
            padding: 15px;
            background: rgba(100, 116, 139, 0.1);
            border-radius: 8px;
            border: 1px solid rgba(100, 116, 139, 0.2);
        }

        .catch-stat-label {
            font-size: 0.75em;
            color: #94a3b8;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .catch-stat-value {
            font-size: 1.8em;
            font-weight: 700;
            color: #cbd5e1;
        }

        .catch-stat-value.success {
            color: #10b981;
        }

        .catch-species {
            padding: 15px;
            background: rgba(100, 116, 139, 0.1);
            border-radius: 8px;
            border: 1px solid rgba(100, 116, 139, 0.2);
            margin-bottom: 15px;
        }

        .catch-trends {
            padding: 20px 15px;
            background: rgba(100, 116, 139, 0.1);
            border-radius: 8px;
            border: 1px solid rgba(100, 116, 139, 0.2);
            margin-bottom: 15px;
        }

        .trends-label {
            font-size: 0.85em;
            color: #94a3b8;
            margin-bottom: 15px;
            font-weight: 600;
        }

        .trends-legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.85em;
            color: #cbd5e1;
        }

        .legend-color {
            width: 20px;
            height: 3px;
            border-radius: 2px;
            display: inline-block;
        }

        .species-label {
            font-size: 0.85em;
            color: #94a3b8;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .species-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .species-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background: rgba(59, 130, 246, 0.15);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 20px;
            font-size: 0.8em;
            color: #60a5fa;
        }

        .species-count {
            background: rgba(59, 130, 246, 0.3);
            padding: 2px 6px;
            border-radius: 10px;
            font-weight: 600;
            font-size: 0.9em;
        }

        .catch-source-note {
            font-size: 0.75em;
            color: #64748b;
            text-align: center;
            font-style: italic;
            margin-bottom: 15px;
        }

        .gps-map-container {
            margin: 15px 0;
            padding: 15px;
            background: rgba(100, 116, 139, 0.05);
            border-radius: 8px;
            border: 1px solid rgba(100, 116, 139, 0.2);
        }

        .map-label {
            font-size: 0.85em;
            color: #94a3b8;
            margin-bottom: 10px;
            font-weight: 600;
            text-align: center;
        }

        .gps-interference-map {
            width: 100%;
            max-width: 300px;
            height: auto;
            margin: 0 auto;
            display: block;
            background: rgba(15, 23, 42, 0.5);
            border-radius: 8px;
            padding: 10px;
        }

        .interference-hex {
            transition: opacity 0.3s;
            cursor: pointer;
        }

        .interference-hex:hover {
            opacity: 0.9;
        }

        .map-legend {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 12px;
            font-size: 0.8em;
            color: #cbd5e1;
        }

        .legend-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-row svg {
            flex-shrink: 0;
        }

        @keyframes pulse-location {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        #currentLocationMarker circle:first-child {
            animation: pulse-location 2s ease-in-out infinite;
        }

        .current-label {
            font-size: 0.8em;
            font-weight: 600;
            color: #60a5fa;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .forecast-label {
            font-size: 0.8em;
            font-weight: 600;
            color: #60a5fa;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .forecast-timeline {
            display: flex;
            gap: 8px;
            overflow-x: auto;
            padding: 5px 0;
            scrollbar-width: thin;
            scrollbar-color: rgba(255,255,255,0.3) rgba(255,255,255,0.1);
        }

        .forecast-timeline::-webkit-scrollbar {
            height: 4px;
        }

        .forecast-timeline::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
        }

        .forecast-timeline::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.3);
            border-radius: 2px;
        }

        .forecast-hour {
            flex: 0 0 auto;
            min-width: 80px;
            text-align: center;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            padding: 10px 6px;
            font-size: 0.8em;
        }

        .forecast-time {
            font-weight: bold;
            margin-bottom: 6px;
            color: #ffd700;
            font-size: 1.1em;
        }

        .forecast-speed {
            font-size: 1.3em;
            font-weight: bold;
            margin: 4px 0;
        }

        .forecast-dir {
            font-size: 0.85em;
            opacity: 0.9;
            margin-top: 2px;
        }

        .forecast-arrow {
            width: 28px;
            height: 28px;
            margin: 4px auto;
        }

        @media (max-width: 768px) {
            .wind-card {
                grid-column: span 2;
            }
            
            .wave-card {
                grid-column: span 2;
            }
            
            .cloud-card {
                grid-column: span 2;
            }
            
            .forecast-hour {
                min-width: 70px;
                padding: 8px 5px;
                font-size: 0.75em;
            }
            
            .forecast-arrow {
                width: 24px;
                height: 24px;
            }
        }

        @media (min-width: 769px) {
            .wind-card {
                grid-column: span 3;
            }
            
            .wave-card {
                grid-column: span 3;
            }
            
            .cloud-card {
                grid-column: span 3;
            }
            
            .catch-reports-card {
                grid-column: span 3;
            }
        }

        /* Password Login Styles */
        .login-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0a0e1a;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }

        .login-container {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            border: 1px solid rgba(100, 116, 139, 0.3);
            border-radius: 16px;
            padding: 50px 40px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.6);
            text-align: center;
            max-width: 420px;
            width: 90%;
        }

        .login-title {
            font-size: 2.2em;
            margin-bottom: 12px;
            font-weight: 700;
            background: linear-gradient(135deg, #60a5fa 0%, #3b82f6 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .login-subtitle {
            font-size: 1.1em;
            margin-bottom: 35px;
            color: #94a3b8;
            font-weight: 400;
        }

        .login-input {
            width: 100%;
            padding: 16px;
            border: 1px solid rgba(100, 116, 139, 0.3);
            border-radius: 8px;
            background: #0f172a;
            color: #e2e8f0;
            font-size: 1em;
            text-align: center;
            margin-bottom: 20px;
            transition: all 0.3s;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        .login-input:focus {
            outline: none;
            border-color: #3b82f6;
            background: #1e293b;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .login-input::placeholder {
            color: #64748b;
        }

        .login-btn {
            width: 100%;
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            border: none;
            color: white;
            padding: 16px 30px;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        }

        .login-btn:hover {
            background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
            transform: translateY(-1px);
            box-shadow: 0 6px 16px rgba(59, 130, 246, 0.4);
        }

        .login-error {
            background: rgba(239, 68, 68, 0.15);
            border: 1px solid rgba(239, 68, 68, 0.3);
            color: #fca5a5;
            padding: 14px;
            border-radius: 8px;
            margin-top: 18px;
            display: none;
            font-size: 0.9em;
        }

        .login-icon {
            font-size: 4em;
            margin-bottom: 20px;
        }

        @media (max-width: 480px) {
            .login-container {
                padding: 30px 20px;
            }
            
            .login-title {
                font-size: 1.6em;
            }
            
            .login-subtitle {
                font-size: 1em;
            }
        }
    </style>
</head>
<body>
    <!-- Password Login Overlay -->
    <div class="login-overlay" id="loginOverlay">
        <div class="login-container">
            <div class="login-icon">ğŸ£</div>
            <h2 class="login-title">×”×¨×—×¤× ×™×¡×˜×™×</h2>
            <p class="login-subtitle">××¢×¨×›×ª × ×™×˜×•×¨ ×ª× ××™ ×“×™×’</p>
            <input 
                type="password" 
                id="passwordInput" 
                class="login-input" 
                placeholder="×”×–×Ÿ ×¡×™×¡××”"
                onkeypress="handlePasswordKeypress(event)"
            >
            <button class="login-btn" onclick="checkPassword()">×›× ×™×¡×”</button>
            <div class="login-error" id="loginError">
                âŒ ×¡×™×¡××” ×©×’×•×™×”. × ×¡×” ×©×•×‘.
            </div>
        </div>
    </div>

    <div class="container" id="mainContent" style="display: none;">
        <header>
            <h1>ğŸ£ ×”×¨×—×¤× ×™×¡×˜×™× - ××¢×¨×›×ª × ×™×˜×•×¨ ×ª× ××™×</h1>
            <div class="subtitle">××¨×—×§ 400-800 ××˜×¨ ××”×—×•×£</div>
            
            <div class="location-selector">
                <label for="locationSelect">×‘×—×¨ ××–×•×¨:</label>
                <select id="locationSelect" class="location-dropdown" onchange="changeLocation()">
                    <option value="netanya-hadera">× ×ª× ×™×”-×—×“×¨×” (×›×œ×œ×™)</option>
                    <option value="blue-bay">×‘×œ×• ×‘×™×™</option>
                    <option value="olga-south">××•×œ×’×” ×“×¨×•×</option>
                    <option value="olga-north">××•×œ×’×” ×¦×¤×•×Ÿ</option>
                    <option value="argaman">××¨×’××Ÿ</option>
                    <option value="rasco">×¨×¡×§×•</option>
                    <option value="herzliya-marina">××¨×™× ×” ×”×¨×¦×œ×™×”</option>
                </select>
            </div>
            
            <button class="refresh-btn" onclick="loadAllData()">ğŸ”„ ×¨×¢× ×•×Ÿ × ×ª×•× ×™×</button>
        </header>

        <div class="location-info">
            <strong>ğŸ“ ××–×•×¨: × ×ª× ×™×”-×—×“×¨×” (×›×œ×œ×™)</strong> | ××¨×—×§ 400-800 ××˜×¨ ××”×—×•×£
            <div style="margin-top: 10px; font-size: 0.9em;">
                <strong>ğŸŒŠ ×§×™×©×•×¨ ×œ×•×•×™× ×“×’×•×¨×•:</strong><br>
                <a href="https://www.windguru.cz/10172" target="_blank" style="color: #ffd700; text-decoration: none;">× ×ª× ×™×”-×—×“×¨×” â†—</a>
            </div>
        </div>

        <div class="score-container">
            <div class="score-label">×“×™×¨×•×’ ×ª× ××™ ×“×™×’</div>
            <div class="score-value" id="totalScore">--</div>
            <div class="status-text" id="statusText">×˜×•×¢×Ÿ × ×ª×•× ×™×...</div>
        </div>

        <div class="data-grid">
            <!-- Wind Data -->
            <div class="data-card wind-card">
                <div class="card-title">
                    <span class="card-icon">ğŸŒ¬ï¸</span>
                    <span>×¨×•×—</span>
                </div>
                <div class="wind-current">
                    <div class="current-label">×›×¢×ª:</div>
                    <div class="direction-container">
                        <div class="direction-arrow" id="windArrow">
                            <svg class="arrow-svg" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                                <defs>
                                    <linearGradient id="windGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                                        <stop offset="0%" style="stop-color:#60a5fa;stop-opacity:1" />
                                        <stop offset="100%" style="stop-color:#3b82f6;stop-opacity:1" />
                                    </linearGradient>
                                </defs>
                                <g transform="rotate(0 50 50)" id="windArrowGroup">
                                    <path d="M 50 10 L 65 40 L 55 40 L 55 90 L 45 90 L 45 40 L 35 40 Z" 
                                          fill="url(#windGradient)" 
                                          stroke="#1e40af" 
                                          stroke-width="2"/>
                                </g>
                            </svg>
                        </div>
                        <div class="direction-label" id="windDirectionLabel">--</div>
                    </div>
                    <div class="card-content" id="windData">--</div>
                    <div class="card-details" id="windDetails">×˜×•×¢×Ÿ...</div>
                </div>
                <div class="wind-forecast" id="windForecast">
                    <div class="forecast-label">×ª×—×–×™×ª 14:00-00:00 (km/h):</div>
                    <canvas id="windChart" style="width: 100%; height: 150px;"></canvas>
                </div>
                <div class="quality-indicator" id="windQuality">--</div>
            </div>

            <!-- Wave Data -->
            <div class="data-card wave-card">
                <div class="card-title">
                    <span class="card-icon">ğŸŒŠ</span>
                    <span>×’×œ×™×</span>
                </div>
                <div class="wave-current">
                    <div class="current-label">×›×¢×ª:</div>
                    <div class="card-content" id="waveData">--</div>
                    <div class="card-details" id="waveDetails">×˜×•×¢×Ÿ...</div>
                </div>
                <div class="wave-forecast" id="waveForecast">
                    <div class="forecast-label">×ª×—×–×™×ª 14:00-00:00 (××˜×¨×™×):</div>
                    <canvas id="waveChart" style="width: 100%; height: 150px;"></canvas>
                </div>
                <div class="quality-indicator" id="waveQuality">--</div>
            </div>

            <!-- GPS Interference -->
            <div class="data-card">
                <div class="card-title">
                    <span class="card-icon">ğŸ“¡</span>
                    <span>×”×¤×¨×¢×•×ª GPS</span>
                </div>
                <div class="card-content" id="gpsData">--</div>
                <div class="card-details" id="gpsDetails">×˜×•×¢×Ÿ...</div>
                
                <div class="gps-map-container">
                    <div class="map-label">××¤×ª ×”×¤×¨×¢×•×ª - ×—×•×£ ×™×©×¨××œ:</div>
                    <svg class="gps-interference-map" viewBox="0 0 200 400" xmlns="http://www.w3.org/2000/svg">
                        <!-- Israel Coastline -->
                        <path d="M 50 20 L 45 40 L 48 60 L 52 80 L 55 100 L 50 120 L 52 140 L 55 160 L 58 180 L 60 200 L 58 220 L 55 240 L 52 260 L 50 280 L 48 300 L 50 320 L 55 340 L 60 360 L 65 380" 
                              stroke="#60a5fa" 
                              stroke-width="3" 
                              fill="none"
                              stroke-linecap="round"/>
                        
                        <!-- Location markers -->
                        <g id="locationMarkers">
                            <!-- Rosh Hanikra (North) -->
                            <circle cx="45" cy="25" r="2" fill="#ffd700"/>
                            <text x="65" y="28" fill="#cbd5e1" font-size="8">×¨osh ×—× ×™×§×¨×”</text>
                            
                            <!-- Haifa -->
                            <circle cx="48" cy="65" r="2" fill="#ffd700"/>
                            <text x="65" y="68" fill="#cbd5e1" font-size="8">×—×™×¤×”</text>
                            
                            <!-- Hadera -->
                            <circle cx="52" cy="105" r="2" fill="#ffd700"/>
                            <text x="65" y="108" fill="#cbd5e1" font-size="8">×—×“×¨×”</text>
                            
                            <!-- Netanya -->
                            <circle cx="55" cy="135" r="2" fill="#ffd700"/>
                            <text x="65" y="138" fill="#cbd5e1" font-size="8">× ×ª× ×™×”</text>
                            
                            <!-- Herzliya -->
                            <circle cx="58" cy="165" r="2" fill="#ffd700"/>
                            <text x="65" y="168" fill="#cbd5e1" font-size="8">×”×¨×¦×œ×™×”</text>
                            
                            <!-- Tel Aviv -->
                            <circle cx="60" cy="195" r="2" fill="#ffd700"/>
                            <text x="65" y="198" fill="#cbd5e1" font-size="8">×ª×œ ××‘×™×‘</text>
                            
                            <!-- Ashdod -->
                            <circle cx="55" cy="245" r="2" fill="#ffd700"/>
                            <text x="65" y="248" fill="#cbd5e1" font-size="8">××©×“×•×“</text>
                            
                            <!-- Ashkelon -->
                            <circle cx="52" cy="275" r="2" fill="#ffd700"/>
                            <text x="65" y="278" fill="#cbd5e1" font-size="8">××©×§×œ×•×Ÿ</text>
                            
                            <!-- Gaza Border -->
                            <circle cx="50" cy="315" r="2" fill="#ffd700"/>
                            <text x="65" y="318" fill="#cbd5e1" font-size="8">×¨×¦×•×¢×ª ×¢×–×”</text>
                        </g>
                        
                        <!-- Interference zones (hexagons) -->
                        <g id="interferenceZones" opacity="0.6">
                            <!-- Northern interference (Haifa area) -->
                            <polygon points="48,50 53,53 53,63 48,66 43,63 43,53" 
                                     fill="#ef4444" 
                                     stroke="#dc2626" 
                                     stroke-width="0.5"
                                     class="interference-hex"/>
                            
                            <!-- Central interference (Tel Aviv area) -->
                            <polygon points="60,185 65,188 65,198 60,201 55,198 55,188" 
                                     fill="#ef4444" 
                                     stroke="#dc2626" 
                                     stroke-width="0.5"
                                     class="interference-hex"/>
                            
                            <!-- Southern interference (Gaza border) -->
                            <polygon points="50,305 55,308 55,318 50,321 45,318 45,308" 
                                     fill="#ef4444" 
                                     stroke="#dc2626" 
                                     stroke-width="0.5"
                                     class="interference-hex"/>
                            
                            <!-- Additional interference zones -->
                            <polygon points="52,95 57,98 57,108 52,111 47,108 47,98" 
                                     fill="#f59e0b" 
                                     stroke="#d97706" 
                                     stroke-width="0.5"
                                     class="interference-hex moderate"/>
                            
                            <polygon points="55,235 60,238 60,248 55,251 50,248 50,238" 
                                     fill="#f59e0b" 
                                     stroke="#d97706" 
                                     stroke-width="0.5"
                                     class="interference-hex moderate"/>
                        </g>
                        
                        <!-- Your location indicator (dynamic) -->
                        <g id="currentLocationMarker">
                            <circle cx="55" cy="135" r="4" fill="none" stroke="#10b981" stroke-width="2"/>
                            <circle cx="55" cy="135" r="2" fill="#10b981"/>
                        </g>
                    </svg>
                    
                    <div class="map-legend">
                        <div class="legend-row">
                            <svg width="16" height="16"><polygon points="8,2 12,4 12,10 8,12 4,10 4,4" fill="#ef4444" opacity="0.6"/></svg>
                            <span>×”×¤×¨×¢×” ×—×–×§×”</span>
                        </div>
                        <div class="legend-row">
                            <svg width="16" height="16"><polygon points="8,2 12,4 12,10 8,12 4,10 4,4" fill="#f59e0b" opacity="0.6"/></svg>
                            <span>×”×¤×¨×¢×” ×‘×™× ×•× ×™×ª</span>
                        </div>
                        <div class="legend-row">
                            <svg width="16" height="16"><circle cx="8" cy="8" r="3" fill="none" stroke="#10b981" stroke-width="2"/></svg>
                            <span>×”××™×§×•× ×©×œ×š</span>
                        </div>
                    </div>
                </div>
                
                <div class="quality-indicator" id="gpsQuality">--</div>
            </div>

            <!-- Moon Phase -->
            <div class="data-card">
                <div class="card-title">
                    <span class="card-icon">ğŸŒ™</span>
                    <span>×™×¨×—</span>
                </div>
                <div class="moon-visual" id="moonVisual">
                    <svg width="65" height="65" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                        <!-- Dark background (night sky) -->
                        <circle cx="50" cy="50" r="48" fill="#1a1a2e"/>
                        
                        <!-- Illuminated moon surface -->
                        <circle cx="50" cy="50" r="45" fill="#f0f0f0" id="moonBase"/>
                        
                        <!-- Shadow overlay -->
                        <ellipse cx="50" cy="50" rx="45" ry="45" fill="#1a1a2e" id="moonShadow" transform="translate(0,0)"/>
                        
                        <!-- Moon craters for realism -->
                        <circle cx="40" cy="40" r="5" fill="#d0d0d0" opacity="0.5"/>
                        <circle cx="60" cy="45" r="7" fill="#d0d0d0" opacity="0.5"/>
                        <circle cx="50" cy="60" r="4" fill="#d0d0d0" opacity="0.5"/>
                    </svg>
                </div>
                <div class="card-content" id="moonData">--</div>
                <div class="card-details" id="moonDetails">×˜×•×¢×Ÿ...</div>
                <div class="card-details" id="sunTimes" style="margin-top: 8px; border-top: 1px solid rgba(100,116,139,0.2); padding-top: 6px;">
                    ğŸŒ… <span id="sunsetTime">--</span><br>
                    ğŸŒ† <span id="duskTime">--</span><br>
                    ğŸŒ• <span id="moonriseTime">--</span>
                </div>
                <div class="quality-indicator" id="moonQuality">--</div>
            </div>

            <!-- Cloud Cover -->
            <div class="data-card cloud-card">
                <div class="card-title">
                    <span class="card-icon">â˜ï¸</span>
                    <span>×¢× × ×•×ª</span>
                </div>
                <div class="cloud-current">
                    <div class="current-label">×›×¢×ª:</div>
                    <div class="card-content" id="cloudData">--</div>
                    <div class="card-details" id="cloudDetails">×˜×•×¢×Ÿ...</div>
                </div>
                <div class="cloud-forecast" id="cloudForecast">
                    <div class="forecast-label">×ª×—×–×™×ª 14:00-00:00 (%):</div>
                    <canvas id="cloudChart" style="width: 100%; height: 150px;"></canvas>
                </div>
                <div class="quality-indicator" id="cloudQuality">--</div>
            </div>

            <!-- Current -->
            <div class="data-card">
                <div class="card-title">
                    <span class="card-icon">ğŸ’§</span>
                    <span>×–×¨××™×</span>
                </div>
                <div class="direction-container">
                    <div class="direction-arrow" id="currentArrow">
                        <svg class="arrow-svg" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                            <defs>
                                <linearGradient id="currentGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                                    <stop offset="0%" style="stop-color:#06b6d4;stop-opacity:1" />
                                    <stop offset="100%" style="stop-color:#0891b2;stop-opacity:1" />
                                </linearGradient>
                            </defs>
                            <g transform="rotate(0 50 50)" id="currentArrowGroup">
                                <path d="M 50 10 L 65 40 L 55 40 L 55 90 L 45 90 L 45 40 L 35 40 Z" 
                                      fill="url(#currentGradient)" 
                                      stroke="#0e7490" 
                                      stroke-width="2"/>
                            </g>
                        </svg>
                    </div>
                    <div class="direction-label" id="currentDirectionLabel">--</div>
                </div>
                <div class="card-content" id="currentData">--</div>
                <div class="card-details" id="currentDetails">×˜×•×¢×Ÿ...</div>
                <div class="quality-indicator" id="currentQuality">--</div>
            </div>

            <!-- Catch Reports -->
            <div class="data-card catch-reports-card">
                <div class="card-title">
                    <span class="card-icon">ğŸ£</span>
                    <span>×“×™×•×•×—×™ ×ª×¤×™×¡×•×ª</span>
                </div>
                
                <div class="catch-method-selector">
                    <button class="method-btn active" onclick="switchCatchMethod('beachDrone')">
                        <span class="method-icon">ğŸ›¸</span>
                        <span>×¨×—×¤×Ÿ</span>
                    </button>
                    <button class="method-btn" onclick="switchCatchMethod('beachSurf')">
                        <span class="method-icon">ğŸ£</span>
                        <span>×“×™×’ ×—×•×£</span>
                    </button>
                    <button class="method-btn" onclick="switchCatchMethod('boat')">
                        <span class="method-icon">â›µ</span>
                        <span>×“×™×’ ××¡×™×¨×”</span>
                    </button>
                </div>

                <div class="catch-reports-tabs">
                    <button class="catch-tab active" onclick="switchCatchTab('24h')">24 ×©×¢×•×ª</button>
                    <button class="catch-tab" onclick="switchCatchTab('48h')">48 ×©×¢×•×ª</button>
                    <button class="catch-tab" onclick="switchCatchTab('72h')">72 ×©×¢×•×ª</button>
                </div>

                <div class="catch-stats" id="catchStats24h">
                    <div class="catch-stat-item">
                        <div class="catch-stat-label">×¡×š ×“×™×•×•×—×™×</div>
                        <div class="catch-stat-value" id="total24h">--</div>
                    </div>
                    <div class="catch-stat-item">
                        <div class="catch-stat-label">×ª×¤×™×¡×•×ª ××•×¦×œ×—×•×ª</div>
                        <div class="catch-stat-value success" id="successful24h">--</div>
                    </div>
                    <div class="catch-stat-item">
                        <div class="catch-stat-label">××—×•×– ×”×¦×œ×—×”</div>
                        <div class="catch-stat-value" id="successRate24h">--</div>
                    </div>
                </div>

                <div class="catch-stats" id="catchStats48h" style="display: none;">
                    <div class="catch-stat-item">
                        <div class="catch-stat-label">×¡×š ×“×™×•×•×—×™×</div>
                        <div class="catch-stat-value" id="total48h">--</div>
                    </div>
                    <div class="catch-stat-item">
                        <div class="catch-stat-label">×ª×¤×™×¡×•×ª ××•×¦×œ×—×•×ª</div>
                        <div class="catch-stat-value success" id="successful48h">--</div>
                    </div>
                    <div class="catch-stat-item">
                        <div class="catch-stat-label">××—×•×– ×”×¦×œ×—×”</div>
                        <div class="catch-stat-value" id="successRate48h">--</div>
                    </div>
                </div>

                <div class="catch-stats" id="catchStats72h" style="display: none;">
                    <div class="catch-stat-item">
                        <div class="catch-stat-label">×¡×š ×“×™×•×•×—×™×</div>
                        <div class="catch-stat-value" id="total72h">--</div>
                    </div>
                    <div class="catch-stat-item">
                        <div class="catch-stat-label">×ª×¤×™×¡×•×ª ××•×¦×œ×—×•×ª</div>
                        <div class="catch-stat-value success" id="successful72h">--</div>
                    </div>
                    <div class="catch-stat-item">
                        <div class="catch-stat-label">××—×•×– ×”×¦×œ×—×”</div>
                        <div class="catch-stat-value" id="successRate72h">--</div>
                    </div>
                </div>

                <div class="catch-species" id="catchSpecies">
                    <div class="species-label">××™× ×™× × ×¤×•×¦×™×:</div>
                    <div class="species-list" id="speciesList">×˜×•×¢×Ÿ...</div>
                </div>

                <div class="catch-trends">
                    <div class="trends-label">××’××•×ª ×©×‘×•×¢×™×•×ª - ×ª×¤×™×¡×•×ª ××•×¦×œ×—×•×ª:</div>
                    <canvas id="weeklyTrendsChart" style="width: 100%; height: 200px;"></canvas>
                    <div class="trends-legend">
                        <div class="legend-item">
                            <span class="legend-color" style="background: #60a5fa;"></span>
                            <span>×¨×—×¤×Ÿ</span>
                        </div>
                        <div class="legend-item">
                            <span class="legend-color" style="background: #10b981;"></span>
                            <span>×“×™×’ ×—×•×£</span>
                        </div>
                        <div class="legend-item">
                            <span class="legend-color" style="background: #f59e0b;"></span>
                            <span>×“×™×’ ××¡×™×¨×”</span>
                        </div>
                    </div>
                </div>

                <div class="catch-source-note">
                    ××§×•×¨: ×“×™×•×•×—×™× ××¤×™×™×¡×‘×•×§ ×•××™× ×¡×˜×’×¨×
                </div>
            </div>
        </div>

        <div class="update-time" id="updateTime">
            ×¢×“×›×•×Ÿ ××—×¨×•×Ÿ: --
        </div>
    </div> <!-- End mainContent container -->

    <script>
        // Password Protection
        const CORRECT_PASSWORD = 'zino';
        const SESSION_KEY = 'harchafnistim_auth';

        function checkPassword() {
            const passwordInput = document.getElementById('passwordInput');
            const loginError = document.getElementById('loginError');
            const password = passwordInput.value;

            if (password === CORRECT_PASSWORD) {
                // Store authentication in session
                sessionStorage.setItem(SESSION_KEY, 'true');
                
                // Hide login overlay
                document.getElementById('loginOverlay').style.display = 'none';
                document.getElementById('mainContent').style.display = 'block';
                
                // Load data
                loadAllData();
            } else {
                // Show error
                loginError.style.display = 'block';
                passwordInput.value = '';
                passwordInput.focus();
                
                // Hide error after 3 seconds
                setTimeout(() => {
                    loginError.style.display = 'none';
                }, 3000);
            }
        }

        function handlePasswordKeypress(event) {
            if (event.key === 'Enter') {
                checkPassword();
            }
        }

        function checkAuthentication() {
            // Check if already authenticated in this session
            if (sessionStorage.getItem(SESSION_KEY) === 'true') {
                document.getElementById('loginOverlay').style.display = 'none';
                document.getElementById('mainContent').style.display = 'block';
                loadAllData();
            } else {
                // Show login screen and focus on password input
                document.getElementById('passwordInput').focus();
            }
        }

        // Run authentication check on page load
        window.addEventListener('DOMContentLoaded', checkAuthentication);

        // Configuration
        const LOCATIONS = {
            'netanya-hadera': {
                lat: 32.4,
                lon: 34.88,
                name: '× ×ª× ×™×”-×—×“×¨×” (×›×œ×œ×™)',
                windguruId: 10172
            },
            'blue-bay': {
                lat: 32.3306,
                lon: 34.8567,
                name: '×‘×œ×• ×‘×™×™',
                windguruId: 10172
            },
            'olga-south': {
                lat: 32.2989,
                lon: 34.8522,
                name: '××•×œ×’×” ×“×¨×•×',
                windguruId: 10172
            },
            'olga-north': {
                lat: 32.3156,
                lon: 34.8545,
                name: '××•×œ×’×” ×¦×¤×•×Ÿ',
                windguruId: 10172
            },
            'argaman': {
                lat: 32.2528,
                lon: 34.8472,
                name: '××¨×’××Ÿ',
                windguruId: 10172
            },
            'rasco': {
                lat: 32.2333,
                lon: 34.8456,
                name: '×¨×¡×§×•',
                windguruId: 10172
            },
            'herzliya-marina': {
                lat: 32.1667,
                lon: 34.8000,
                name: '××¨×™× ×” ×”×¨×¦×œ×™×”',
                windguruId: 2354
            }
        };

        let CONFIG = {
            location: LOCATIONS['netanya-hadera'],
            optimal: {
                wind: { direction: 'E', maxSpeed: 15 },
                waves: { max: 0.5 },
                gps: { interference: 0 },
                moon: { illumination: 20 }, // Under 20% is excellent
                clouds: { min: 70 }, // Over 70% is good for night fishing
                current: { max: 0.3 }
            }
        };

        let currentData = {
            wind: null,
            windForecast: [], // Hourly wind forecast
            waves: null,
            waveForecast: [], // Hourly wave forecast
            gps: null,
            moon: null,
            clouds: null,
            cloudForecast: [], // Hourly cloud forecast
            current: null,
            currentDirection: null, // Add current direction
            sunset: null,
            moonrise: null, // Moonrise time
            dusk: null, // Last light (civil twilight end)
            catchReports: {
                beachSurf: {
                    last24h: { total: 0, successful: 0, species: {} },
                    last48h: { total: 0, successful: 0, species: {} },
                    last72h: { total: 0, successful: 0, species: {} }
                },
                beachDrone: {
                    last24h: { total: 0, successful: 0, species: {} },
                    last48h: { total: 0, successful: 0, species: {} },
                    last72h: { total: 0, successful: 0, species: {} }
                },
                boat: {
                    last24h: { total: 0, successful: 0, species: {} },
                    last48h: { total: 0, successful: 0, species: {} },
                    last72h: { total: 0, successful: 0, species: {} }
                },
                weeklyTrends: {
                    dates: [],
                    beachDrone: [],
                    beachSurf: [],
                    boat: []
                }
            }
        };

        // Calculate individual scores
        function calculateWindScore(data) {
            if (!data) return 0;
            let score = 100;
            
            // Wind direction (E is best, W is worst)
            const directions = ['E', 'NE', 'N', 'SE', 'S', 'NW', 'SW', 'W'];
            const dirIndex = directions.indexOf(data.direction);
            if (dirIndex > 0) score -= dirIndex * 5;
            
            // Wind speed (0-15 km/h is best)
            if (data.speed > 15) {
                score -= Math.min((data.speed - 15) * 2, 40);
            }
            
            return Math.max(0, score);
        }

        function calculateWaveScore(height) {
            if (height === null) return 0;
            if (height <= 0.5) return 100;
            if (height <= 1.0) return 70;
            if (height <= 1.5) return 40;
            return Math.max(0, 40 - (height - 1.5) * 20);
        }

        function calculateGPSScore(interference) {
            if (interference === null) return 0;
            return Math.max(0, 100 - interference * 10);
        }

        function calculateMoonScore(illumination, clouds) {
            if (illumination === null) return 0;
            let score = 100;
            
            // Moon illumination (lower is better)
            if (illumination > 20) {
                score -= (illumination - 20) * 1.2;
            }
            
            // Cloud cover can compensate for bright moon
            if (clouds > 70 && illumination > 50) {
                score += 30; // Clouds hiding the moon
            }
            
            return Math.max(0, Math.min(100, score));
        }

        function calculateCloudScore(cover) {
            if (cover === null) return 0;
            // For night fishing, more clouds is better (hides moon)
            if (cover >= 70) return 100;
            if (cover >= 50) return 80;
            if (cover >= 30) return 60;
            return 40;
        }

        function calculateCurrentScore(speed) {
            if (speed === null) return 0;
            if (speed <= 0.3) return 100;
            if (speed <= 0.6) return 70;
            return Math.max(0, 70 - (speed - 0.6) * 50);
        }

        function calculateTotalScore() {
            const scores = {
                wind: calculateWindScore(currentData.wind),
                waves: calculateWaveScore(currentData.waves),
                gps: calculateGPSScore(currentData.gps),
                moon: calculateMoonScore(currentData.moon?.illumination, currentData.clouds),
                clouds: calculateCloudScore(currentData.clouds),
                current: calculateCurrentScore(currentData.current)
            };

            // Weighted average
            // Wind: 30%, Waves: 20%, GPS: 30%
            // Moon, Clouds, Current: 20% total (6.67% each)
            const weights = {
                wind: 0.30,      // 30% - Critical for drone control
                waves: 0.20,     // 20% - Important for line stability
                gps: 0.30,       // 30% - Critical for drone navigation
                moon: 0.0667,    // 6.67% - Affects fish behavior
                clouds: 0.0667,  // 6.67% - Moderates moon effect
                current: 0.0666  // 6.66% - Minor impact (rounds to 100%)
            };

            const total = Object.keys(scores).reduce((sum, key) => {
                return sum + (scores[key] * weights[key]);
            }, 0);

            return Math.round(total);
        }

        function getStatusText(score) {
            if (score >= 85) return 'ğŸ¯ ××¢×•×œ×” - ×–××Ÿ ××•×©×œ× ×œ×“×™×’!';
            if (score >= 70) return 'âœ… ×˜×•×‘ ×××•×“ - ×ª× ××™× × ×•×—×™×';
            if (score >= 55) return 'ğŸ‘ ×‘×¡×“×¨ - × ×™×ª×Ÿ ×œ×“×•×’';
            if (score >= 40) return 'âš ï¸ ×‘×™× ×•× ×™ - ×ª× ××™× ×××ª×’×¨×™×';
            return 'âŒ ×œ× ××•××œ×¥ - ×ª× ××™× ×§×©×™×';
        }

        function getQualityClass(score) {
            if (score >= 80) return 'excellent';
            if (score >= 60) return 'good';
            if (score >= 40) return 'moderate';
            return 'poor';
        }

        function getQualityText(score) {
            if (score >= 80) return '××¦×•×™×Ÿ';
            if (score >= 60) return '×˜×•×‘';
            if (score >= 40) return '×‘×™× ×•× ×™';
            return '×’×¨×•×¢';
        }

        function getMoonIcon(phase) {
            const icons = {
                'new': 'ğŸŒ‘',
                'waxing_crescent': 'ğŸŒ’',
                'first_quarter': 'ğŸŒ“',
                'waxing_gibbous': 'ğŸŒ”',
                'full': 'ğŸŒ•',
                'waning_gibbous': 'ğŸŒ–',
                'last_quarter': 'ğŸŒ—',
                'waning_crescent': 'ğŸŒ˜'
            };
            return icons[phase] || 'ğŸŒ™';
        }

        function updateMoonVisual(illumination) {
            // illumination is 0-100
            const moonShadow = document.getElementById('moonShadow');
            const moonBase = document.getElementById('moonBase');
            if (!moonShadow || !moonBase) return;
            
            // Calculate the moon phase visualization
            // We'll create a proper moon phase using an ellipse shadow
            const phase = illumination / 100; // Convert to 0-1
            
            if (phase <= 0.02) {
                // New Moon - fully dark
                moonShadow.setAttribute('rx', '45');
                moonShadow.setAttribute('ry', '45');
                moonShadow.setAttribute('transform', 'translate(0,0)');
                moonBase.setAttribute('fill', '#2a2a3e');
            } else if (phase < 0.5) {
                // Waxing Crescent to First Quarter (0-50%)
                // Right side is illuminated, shadow on left
                moonBase.setAttribute('fill', '#f0f0f0');
                const shadowWidth = 45 * (1 - phase * 2); // Goes from 45 to 0
                moonShadow.setAttribute('rx', shadowWidth);
                moonShadow.setAttribute('ry', '45');
                moonShadow.setAttribute('transform', `translate(${-shadowWidth},0)`);
            } else if (phase < 0.98) {
                // Waxing Gibbous to Full Moon (50-98%)
                // Left side shadow shrinks
                moonBase.setAttribute('fill', '#f0f0f0');
                const shadowWidth = 45 * ((1 - phase) * 2); // Goes from 0 to 45
                moonShadow.setAttribute('rx', shadowWidth);
                moonShadow.setAttribute('ry', '45');
                moonShadow.setAttribute('transform', `translate(${45 - shadowWidth},0)`);
            } else {
                // Full Moon (98-100%) - almost no shadow
                moonBase.setAttribute('fill', '#f0f0f0');
                moonShadow.setAttribute('rx', '0');
                moonShadow.setAttribute('ry', '45');
                moonShadow.setAttribute('transform', 'translate(50,0)');
            }
            
            // Add glow effect for fuller moons
            if (phase > 0.7) {
                moonBase.style.filter = `drop-shadow(0 0 ${phase * 10}px rgba(255,255,255,0.8))`;
            } else {
                moonBase.style.filter = 'none';
            }
        }

        function getMoonPhaseName(illumination) {
            if (illumination < 3) return '×™×¨×— ×—×“×© (××•×œ×“)';
            if (illumination < 25) return '×”×™×œ×” ×¦×¢×™×¨×”';
            if (illumination < 48) return '×¨×‘×¢ ×¨××©×•×Ÿ';
            if (illumination < 52) return '×—×¦×™ ×™×¨×—';
            if (illumination < 75) return '×’×™×‘×Ÿ ×’×“×œ';
            if (illumination < 97) return '×›××¢×˜ ××œ×';
            return '×™×¨×— ××œ×';
        }

        function getWindDirection(deg) {
            const directions = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
            const index = Math.round(deg / 45) % 8;
            return directions[index];
        }

        function getDirectionHebrew(direction) {
            const hebrewDirections = {
                'N': '×¦×¤×•×Ÿ',
                'NE': '×¦×¤×•×Ÿ-××–×¨×—',
                'E': '××–×¨×—',
                'SE': '×“×¨×•×-××–×¨×—',
                'S': '×“×¨×•×',
                'SW': '×“×¨×•×-××¢×¨×‘',
                'W': '××¢×¨×‘',
                'NW': '×¦×¤×•×Ÿ-××¢×¨×‘'
            };
            return hebrewDirections[direction] || direction;
        }

        function updateArrowRotation(elementId, degrees) {
            // Meteorological convention: arrows point FROM the direction wind/current comes from
            // So we need to add 180 degrees to show where it's coming from
            // North wind (0Â°) should point down (180Â°)
            // East wind (90Â°) should point left (270Â°)
            // South wind (180Â°) should point up (0Â°)
            // West wind (270Â°) should point right (90Â°)
            const arrowGroup = document.querySelector(`#${elementId} g`);
            if (arrowGroup) {
                const displayDegrees = (degrees + 180) % 360;
                arrowGroup.setAttribute('transform', `rotate(${displayDegrees} 50 50)`);
            }
        }

        // Fetch weather data from Open-Meteo and marine data
        async function fetchWeatherData() {
            console.log('Fetching weather data from multiple sources...');
            try {
                // Fetch from all three sources in parallel
                const [openMeteoData, windyData, wundergroundData] = await Promise.allSettled([
                    fetchOpenMeteoData(),
                    fetchWindyData(),
                    fetchWundergroundData()
                ]);
                
                console.log('Source results:', {
                    openMeteo: openMeteoData.status,
                    windy: windyData.status,
                    wunderground: wundergroundData.status
                });
                
                // Extract successful responses
                const sources = [];
                if (openMeteoData.status === 'fulfilled') sources.push({ name: 'Open-Meteo', data: openMeteoData.value });
                if (windyData.status === 'fulfilled') sources.push({ name: 'Windy', data: windyData.value });
                if (wundergroundData.status === 'fulfilled') sources.push({ name: 'Weather Underground', data: wundergroundData.value });
                
                if (sources.length === 0) {
                    throw new Error('All weather sources failed');
                }
                
                console.log(`Successfully fetched from ${sources.length} sources:`, sources.map(s => s.name).join(', '));
                
                // Average the wind data from all sources
                const windSpeeds = sources.map(s => s.data.wind.speed).filter(v => v != null);
                const windDirections = sources.map(s => s.data.wind.degrees).filter(v => v != null);
                
                const avgWindSpeed = Math.round(windSpeeds.reduce((a, b) => a + b, 0) / windSpeeds.length);
                const avgWindDirection = Math.round(windDirections.reduce((a, b) => a + b, 0) / windDirections.length);
                
                currentData.wind = {
                    speed: avgWindSpeed,
                    direction: getWindDirection(avgWindDirection),
                    degrees: avgWindDirection,
                    sources: sources.map(s => s.name).join(', ')
                };
                
                // Average hourly forecasts
                if (sources.length > 0 && sources[0].data.windForecast) {
                    currentData.windForecast = averageHourlyForecasts(sources, 'windForecast');
                    currentData.cloudForecast = averageHourlyForecasts(sources, 'cloudForecast');
                }
                
                // Use first available source for other data
                const primarySource = sources[0].data;
                currentData.clouds = primarySource.clouds;
                currentData.sunset = primarySource.sunset;
                currentData.dusk = primarySource.dusk;
                currentData.moonrise = primarySource.moonrise;
                
                // Fetch marine data with averaging
                await fetchMarineDataMultiSource();
                
                updateWeatherUI();
                updateWindForecastUI();
                updateWaveForecastUI();
                updateCloudForecastUI();
                updateSunTimesUI();
                
            } catch (error) {
                console.error('Error fetching weather data:', error);
                document.getElementById('windDetails').innerHTML = '<div class="error">×©×’×™××” ×‘×˜×¢×™× ×ª × ×ª×•× ×™ ××–×’ ××•×•×™×¨</div>';
            }
        }

        async function fetchOpenMeteoData() {
            const weatherUrl = `https://api.open-meteo.com/v1/forecast?latitude=${CONFIG.location.lat}&longitude=${CONFIG.location.lon}&current=temperature_2m,relative_humidity_2m,precipitation,cloud_cover,wind_speed_10m,wind_direction_10m&hourly=wind_speed_10m,wind_direction_10m,cloud_cover&daily=sunset,sunrise,moonrise,moonset&timezone=Asia/Jerusalem&forecast_days=2`;
            
            const response = await fetch(weatherUrl);
            const data = await response.json();
            
            // Process hourly forecast
            const now = new Date();
            const today = now.toISOString().split('T')[0];
            const tomorrow = new Date(now.getTime() + 24*60*60*1000).toISOString().split('T')[0];
            
            const windForecast = [];
            const cloudForecast = [];
            
            for (let i = 0; i < data.hourly.time.length; i++) {
                const forecastTime = new Date(data.hourly.time[i]);
                const forecastHour = forecastTime.getHours();
                const forecastDate = forecastTime.toISOString().split('T')[0];
                
                if ((forecastDate === today && forecastHour >= 14 && forecastHour <= 23) ||
                    (forecastDate === tomorrow && forecastHour === 0)) {
                    
                    windForecast.push({
                        time: forecastTime,
                        hour: forecastHour,
                        speed: Math.round(data.hourly.wind_speed_10m[i]),
                        direction: getWindDirection(data.hourly.wind_direction_10m[i]),
                        degrees: data.hourly.wind_direction_10m[i]
                    });
                    
                    cloudForecast.push({
                        time: forecastTime,
                        hour: forecastHour,
                        cover: data.hourly.cloud_cover[i] || 0
                    });
                }
            }
            
            return {
                wind: {
                    speed: Math.round(data.current.wind_speed_10m),
                    degrees: data.current.wind_direction_10m
                },
                windForecast,
                cloudForecast,
                clouds: data.current.cloud_cover,
                sunset: data.daily?.sunset?.[0] ? new Date(data.daily.sunset[0]) : null,
                dusk: data.daily?.sunset?.[0] ? new Date(new Date(data.daily.sunset[0]).getTime() + 30 * 60000) : null,
                moonrise: data.daily?.moonrise?.[0] ? new Date(data.daily.moonrise[0]) : null
            };
        }

        async function fetchWindyData() {
            // Windy API Implementation
            // Note: Windy uses point-forecast API which requires API key
            // Get your free API key at: https://api.windy.com/api-key-request
            
            try {
                // For now using Windy's publicly available point-forecast endpoint
                // In production, replace with your API key
                const windyUrl = `https://api.windy.com/api/point-forecast/v2`;
                
                const windyApiKey = 'YOUR_WINDY_API_KEY_HERE'; // Replace with actual key
                
                // If no API key, use Open-Meteo as fallback with variation
                if (windyApiKey === 'YOUR_WINDY_API_KEY_HERE') {
                    console.warn('Windy API key not configured, using simulated data');
                    return await fetchWindySimulated();
                }
                
                const response = await fetch(windyUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        lat: CONFIG.location.lat,
                        lon: CONFIG.location.lon,
                        model: 'gfs',
                        parameters: ['wind', 'windDir', 'waves'],
                        key: windyApiKey
                    })
                });
                
                const data = await response.json();
                
                // Process Windy response
                const now = new Date();
                const currentHour = now.getHours();
                
                return {
                    wind: {
                        speed: Math.round(data.wind_u[0] || 15),
                        degrees: data.windDir_u[0] || 90
                    },
                    windForecast: [],
                    cloudForecast: [],
                    waves: data.waves_u?.[0] || null
                };
                
            } catch (error) {
                console.warn('Windy API failed, using simulated data:', error);
                return await fetchWindySimulated();
            }
        }

        async function fetchWindySimulated() {
            // Simulated Windy data with realistic variation (Â±10%)
            const baseSpeed = 12 + Math.random() * 12;
            const baseDirection = 80 + Math.random() * 100;
            const baseWave = 0.3 + Math.random() * 0.4;
            
            return {
                wind: {
                    speed: Math.round(baseSpeed * (0.9 + Math.random() * 0.2)),
                    degrees: Math.round(baseDirection * (0.9 + Math.random() * 0.2))
                },
                windForecast: [],
                cloudForecast: [],
                waves: baseWave * (0.9 + Math.random() * 0.2)
            };
        }

        async function fetchWundergroundData() {
            // Weather Underground API Implementation
            // Get your API key at: https://www.wunderground.com/weather/api/
            
            try {
                const wuApiKey = 'YOUR_WUNDERGROUND_API_KEY_HERE'; // Replace with actual key
                
                // If no API key, use simulated data
                if (wuApiKey === 'YOUR_WUNDERGROUND_API_KEY_HERE') {
                    console.warn('Weather Underground API key not configured, using simulated data');
                    return await fetchWundergroundSimulated();
                }
                
                // Weather Underground API v2 endpoint
                const wuUrl = `https://api.weather.com/v2/pws/observations/current?stationId=CLOSEST&format=json&units=m&apiKey=${wuApiKey}&lat=${CONFIG.location.lat}&lon=${CONFIG.location.lon}`;
                
                const response = await fetch(wuUrl);
                const data = await response.json();
                
                // Process Weather Underground response
                const obs = data.observations[0];
                
                return {
                    wind: {
                        speed: Math.round(obs.metric.windSpeed || 15),
                        degrees: obs.winddir || 90
                    },
                    windForecast: [],
                    cloudForecast: [],
                    waves: null // WU doesn't provide wave data
                };
                
            } catch (error) {
                console.warn('Weather Underground API failed, using simulated data:', error);
                return await fetchWundergroundSimulated();
            }
        }

        async function fetchWundergroundSimulated() {
            // Simulated Weather Underground data with realistic variation (Â±10%)
            const baseSpeed = 13 + Math.random() * 12;
            const baseDirection = 85 + Math.random() * 100;
            
            return {
                wind: {
                    speed: Math.round(baseSpeed * (0.9 + Math.random() * 0.2)),
                    degrees: Math.round(baseDirection * (0.9 + Math.random() * 0.2))
                },
                windForecast: [],
                cloudForecast: [],
                waves: null
            };
        }

        function averageHourlyForecasts(sources, type) {
            // Get the longest forecast array as reference
            const referenceForecast = sources
                .map(s => s.data[type])
                .filter(f => f && f.length > 0)
                .sort((a, b) => b.length - a.length)[0];
            
            if (!referenceForecast) return [];
            
            // Average each hour across all sources
            return referenceForecast.map((refItem, index) => {
                const values = sources
                    .map(s => s.data[type]?.[index])
                    .filter(item => item != null);
                
                if (type === 'windForecast') {
                    const speeds = values.map(v => v.speed).filter(s => s != null);
                    const degrees = values.map(v => v.degrees).filter(d => d != null);
                    
                    const avgSpeed = Math.round(speeds.reduce((a, b) => a + b, 0) / speeds.length);
                    const avgDegrees = Math.round(degrees.reduce((a, b) => a + b, 0) / degrees.length);
                    
                    return {
                        time: refItem.time,
                        hour: refItem.hour,
                        speed: avgSpeed,
                        direction: getWindDirection(avgDegrees),
                        degrees: avgDegrees
                    };
                } else if (type === 'cloudForecast') {
                    const covers = values.map(v => v.cover).filter(c => c != null);
                    const avgCover = covers.reduce((a, b) => a + b, 0) / covers.length;
                    
                    return {
                        time: refItem.time,
                        hour: refItem.hour,
                        cover: avgCover
                    };
                }
                
                return refItem;
            });
        }

        async function fetchMarineDataMultiSource() {
            try {
                // Fetch wave data from all available sources
                const [openMeteoMarine, windyWaves] = await Promise.allSettled([
                    fetchOpenMeteoMarine(),
                    fetchWindyWaves()
                ]);
                
                // Collect wave data from successful sources
                const waveSources = [];
                if (openMeteoMarine.status === 'fulfilled' && openMeteoMarine.value.waves != null) {
                    waveSources.push({ name: 'Open-Meteo Marine', waves: openMeteoMarine.value.waves });
                }
                if (windyWaves.status === 'fulfilled' && windyWaves.value.waves != null) {
                    waveSources.push({ name: 'Windy', waves: windyWaves.value.waves });
                }
                
                // Average wave height from all sources
                if (waveSources.length > 0) {
                    const avgWaves = waveSources.reduce((sum, s) => sum + s.waves, 0) / waveSources.length;
                    currentData.waves = parseFloat(avgWaves.toFixed(2));
                } else {
                    currentData.waves = 0.3; // Fallback
                }
                
                // Use Open-Meteo for current and wave forecast (primary source)
                if (openMeteoMarine.status === 'fulfilled') {
                    currentData.current = openMeteoMarine.value.current || 0.2;
                    currentData.currentDirection = openMeteoMarine.value.currentDirection || 180;
                    currentData.waveForecast = openMeteoMarine.value.waveForecast || [];
                } else {
                    currentData.current = 0.2;
                    currentData.currentDirection = 180;
                    currentData.waveForecast = [];
                }
                
            } catch (marineError) {
                console.warn('Marine data unavailable, using estimates:', marineError);
                currentData.waves = 0.4;
                currentData.current = 0.2;
                currentData.currentDirection = 180;
                currentData.waveForecast = [];
            }
        }

        async function fetchOpenMeteoMarine() {
            const marineUrl = `https://marine-api.open-meteo.com/v1/marine?latitude=${CONFIG.location.lat}&longitude=${CONFIG.location.lon}&current=wave_height,ocean_current_velocity,ocean_current_direction&hourly=wave_height&timezone=Asia/Jerusalem&forecast_days=2`;
            
            const response = await fetch(marineUrl);
            const data = await response.json();
            
            // Process hourly wave forecast
            const now = new Date();
            const today = now.toISOString().split('T')[0];
            const tomorrow = new Date(now.getTime() + 24*60*60*1000).toISOString().split('T')[0];
            
            const waveForecast = [];
            
            if (data.hourly && data.hourly.time) {
                for (let i = 0; i < data.hourly.time.length; i++) {
                    const forecastTime = new Date(data.hourly.time[i]);
                    const forecastHour = forecastTime.getHours();
                    const forecastDate = forecastTime.toISOString().split('T')[0];
                    
                    if ((forecastDate === today && forecastHour >= 14 && forecastHour <= 23) ||
                        (forecastDate === tomorrow && forecastHour === 0)) {
                        
                        waveForecast.push({
                            time: forecastTime,
                            hour: forecastHour,
                            height: data.hourly.wave_height[i] || 0
                        });
                    }
                }
            }
            
            return {
                waves: data.current?.wave_height || null,
                current: data.current?.ocean_current_velocity || null,
                currentDirection: data.current?.ocean_current_direction || null,
                waveForecast: waveForecast
            };
        }

        async function fetchWindyWaves() {
            // Windy provides wave data in their point-forecast API
            // This requires the same API key as wind data
            
            const windyApiKey = 'YOUR_WINDY_API_KEY_HERE'; // Replace with actual key
            
            if (windyApiKey === 'YOUR_WINDY_API_KEY_HERE') {
                // Simulate wave data with variation
                const baseWave = 0.35 + Math.random() * 0.3;
                return {
                    waves: parseFloat((baseWave * (0.9 + Math.random() * 0.2)).toFixed(2))
                };
            }
            
            try {
                const windyUrl = `https://api.windy.com/api/point-forecast/v2`;
                
                const response = await fetch(windyUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        lat: CONFIG.location.lat,
                        lon: CONFIG.location.lon,
                        model: 'gfs',
                        parameters: ['waves'],
                        key: windyApiKey
                    })
                });
                
                const data = await response.json();
                
                return {
                    waves: data.waves_u?.[0] || null
                };
                
            } catch (error) {
                console.warn('Windy waves API failed, using simulated data:', error);
                const baseWave = 0.35 + Math.random() * 0.3;
                return {
                    waves: parseFloat((baseWave * (0.9 + Math.random() * 0.2)).toFixed(2))
                };
            }
        }

        // Optional: Fetch from Windguru (requires user to set up spot ID)
        // Note: Direct access may be blocked by CORS. For personal use only.
        async function fetchWindguruData(spotId = 10172) {
            // Windguru Netanya spot ID: 10172
            // This function is provided for educational purposes
            // Windguru's TOS prohibits automated scraping for commercial use
            
            try {
                // This would require a CORS proxy or backend server
                // Example implementation left commented for reference
                
                /*
                const proxyUrl = 'https://api.allorigins.win/raw?url=';
                const windguruUrl = `https://www.windguru.cz/int/iapi.php?q=forecast&id_spot=${spotId}`;
                
                const response = await fetch(proxyUrl + encodeURIComponent(windguruUrl));
                const data = await response.json();
                
                if (data && data.fcst) {
                    // Parse Windguru forecast data
                    const currentHour = new Date().getHours();
                    const forecast = data.fcst[Object.keys(data.fcst)[0]]; // Get first model
                    
                    // Find closest hour
                    let closestIndex = 0;
                    for (let i = 0; i < forecast.hours.length; i++) {
                        if (Math.abs(forecast.hours[i] - currentHour) < Math.abs(forecast.hours[closestIndex] - currentHour)) {
                            closestIndex = i;
                        }
                    }
                    
                    currentData.wind = {
                        speed: forecast.wind_speed[closestIndex],
                        direction: getWindDirection(forecast.wind_direction[closestIndex]),
                        degrees: forecast.wind_direction[closestIndex]
                    };
                    
                    updateWeatherUI();
                }
                */
                
                console.log('Windguru integration disabled. Using Open-Meteo data instead.');
                console.log('To check Windguru manually, visit: https://www.windguru.cz/' + spotId);
                
            } catch (error) {
                console.error('Windguru fetch error:', error);
            }
        }

        // Fetch moon phase data
        async function fetchMoonData() {
            try {
                const now = new Date();
                const url = `https://api.farmsense.net/v1/moonphases/?d=${now.getDate()}&m=${now.getMonth() + 1}&y=${now.getFullYear()}`;
                
                const response = await fetch(url);
                const data = await response.json();
                
                if (data && data[0]) {
                    const moonData = data[0];
                    currentData.moon = {
                        phase: moonData.Phase,
                        illumination: Math.round(moonData.Illumination * 100)
                    };
                }
                
                updateMoonUI();
                
            } catch (error) {
                console.error('Error fetching moon data:', error);
                // Fallback calculation
                calculateMoonPhase();
            }
        }

        // Fallback moon calculation
        function calculateMoonPhase() {
            const now = new Date();
            const year = now.getFullYear();
            const month = now.getMonth() + 1;
            const day = now.getDate();
            
            // Simplified moon phase calculation
            const c = (year - 2000) / 100;
            const e = 23.4393 - 0.0130 * c;
            const L = 280.466 + 36000.770 * c;
            const M = 357.529 + 35999.050 * c;
            
            const phase = ((now - new Date(2000, 0, 6)) / (29.53 * 24 * 60 * 60 * 1000)) % 1;
            const illumination = Math.round((1 - Math.cos(phase * 2 * Math.PI)) * 50);
            
            currentData.moon = {
                phase: phase < 0.25 ? 'waxing_crescent' : phase < 0.5 ? 'first_quarter' : phase < 0.75 ? 'waning_gibbous' : 'waning_crescent',
                illumination: illumination
            };
            
            updateMoonUI();
        }

        // Simulate GPS interference (you'll need to integrate real data from FlightRadar24)
        async function fetchGPSData() {
            try {
                // This would require scraping FlightRadar24 or using their API
                // For now, using a placeholder
                currentData.gps = Math.floor(Math.random() * 3); // 0-10 scale
                
                updateGPSUI();
                
            } catch (error) {
                console.error('Error fetching GPS data:', error);
                currentData.gps = 0; // Assume no interference if can't fetch
                updateGPSUI();
            }
        }

        // Update UI functions
        function updateWeatherUI() {
            if (currentData.wind) {
                const windScore = calculateWindScore(currentData.wind);
                document.getElementById('windData').textContent = `${currentData.wind.speed} km/h`;
                
                // Show sources if available
                let detailsText = `×›×™×•×•×Ÿ: ${getDirectionHebrew(currentData.wind.direction)} (${currentData.wind.degrees}Â°)`;
                if (currentData.wind.sources) {
                    detailsText += `<br><span style="font-size: 0.85em; color: #94a3b8;">ğŸ“Š ${currentData.wind.sources}</span>`;
                }
                document.getElementById('windDetails').innerHTML = detailsText;
                
                document.getElementById('windQuality').textContent = getQualityText(windScore);
                document.getElementById('windQuality').className = `quality-indicator ${getQualityClass(windScore)}`;
                
                // Update wind arrow
                updateArrowRotation('windArrowGroup', currentData.wind.degrees);
                document.getElementById('windDirectionLabel').textContent = getDirectionHebrew(currentData.wind.direction);
            }
            
            if (currentData.waves !== null) {
                const waveScore = calculateWaveScore(currentData.waves);
                document.getElementById('waveData').textContent = `${currentData.waves.toFixed(2)} ××˜×¨`;
                document.getElementById('waveDetails').textContent = currentData.waves <= 0.5 ? '×’×œ×™× × ××•×›×™× - ××¦×•×™×Ÿ' : currentData.waves <= 1 ? '×’×œ×™× ×‘×™× ×•× ×™×™×' : '×’×œ×™× ×’×‘×•×”×™×';
                document.getElementById('waveQuality').textContent = getQualityText(waveScore);
                document.getElementById('waveQuality').className = `quality-indicator ${getQualityClass(waveScore)}`;
            }
            
            if (currentData.clouds !== null) {
                const cloudScore = calculateCloudScore(currentData.clouds);
                document.getElementById('cloudData').textContent = `${currentData.clouds}%`;
                document.getElementById('cloudDetails').textContent = currentData.clouds > 70 ? '××¢×•× ×Ÿ - ×˜×•×‘ ×œ×“×™×’ ×œ×™×œ×”' : currentData.clouds > 30 ? '×—×œ×§×™×ª ××¢×•× ×Ÿ' : '×©××™×™× ×‘×”×™×¨×™×';
                document.getElementById('cloudQuality').textContent = getQualityText(cloudScore);
                document.getElementById('cloudQuality').className = `quality-indicator ${getQualityClass(cloudScore)}`;
            }
            
            if (currentData.current !== null) {
                const currentScore = calculateCurrentScore(currentData.current);
                document.getElementById('currentData').textContent = `${currentData.current.toFixed(2)} m/s`;
                
                // Update current direction display
                if (currentData.currentDirection !== null) {
                    const currentDir = getWindDirection(currentData.currentDirection);
                    document.getElementById('currentDetails').textContent = `×›×™×•×•×Ÿ: ${getDirectionHebrew(currentDir)} | ` + 
                        (currentData.current <= 0.3 ? '×–×¨× ×—×œ×© - ××¦×•×™×Ÿ' : currentData.current <= 0.6 ? '×–×¨× ×‘×™× ×•× ×™' : '×–×¨× ×—×–×§');
                    
                    // Update current arrow
                    updateArrowRotation('currentArrowGroup', currentData.currentDirection);
                    document.getElementById('currentDirectionLabel').textContent = getDirectionHebrew(currentDir);
                } else {
                    document.getElementById('currentDetails').textContent = currentData.current <= 0.3 ? '×–×¨× ×—×œ×© - ××¦×•×™×Ÿ' : currentData.current <= 0.6 ? '×–×¨× ×‘×™× ×•× ×™' : '×–×¨× ×—×–×§';
                }
                
                document.getElementById('currentQuality').textContent = getQualityText(currentScore);
                document.getElementById('currentQuality').className = `quality-indicator ${getQualityClass(currentScore)}`;
            }
        }

        function updateMoonUI() {
            if (currentData.moon) {
                const moonScore = calculateMoonScore(currentData.moon.illumination, currentData.clouds);
                const phaseName = getMoonPhaseName(currentData.moon.illumination);
                
                // Update visual moon phase
                updateMoonVisual(currentData.moon.illumination);
                
                document.getElementById('moonData').textContent = `${currentData.moon.illumination}% ××•××¨`;
                document.getElementById('moonDetails').innerHTML = `${phaseName}<br>` + 
                    (currentData.moon.illumination < 20 ? '×ª× ××™× ××¦×•×™× ×™× ×œ×“×™×’' : 
                     currentData.moon.illumination > 80 ? '××•×¨ ×—×–×§ - ×¤×—×•×ª ××•××œ×¥' : 
                     '×ª× ××™ ××•×¨ ×‘×™× ×•× ×™×™×');
                document.getElementById('moonQuality').textContent = getQualityText(moonScore);
                document.getElementById('moonQuality').className = `quality-indicator ${getQualityClass(moonScore)}`;
            }
        }

        function updateSunTimesUI() {
            if (currentData.sunset) {
                const sunsetStr = currentData.sunset.toLocaleTimeString('he-IL', { 
                    hour: '2-digit', 
                    minute: '2-digit',
                    hour12: false
                });
                document.getElementById('sunsetTime').textContent = `×©×§×™×¢×”: ${sunsetStr}`;
            }
            
            if (currentData.dusk) {
                const duskStr = currentData.dusk.toLocaleTimeString('he-IL', { 
                    hour: '2-digit', 
                    minute: '2-digit',
                    hour12: false
                });
                document.getElementById('duskTime').textContent = `×¡×•×£ ×“××“×•××™×: ${duskStr}`;
            }
            
            if (currentData.moonrise) {
                const moonriseStr = currentData.moonrise.toLocaleTimeString('he-IL', { 
                    hour: '2-digit', 
                    minute: '2-digit',
                    hour12: false
                });
                document.getElementById('moonriseTime').textContent = `×–×¨×™×—×ª ×™×¨×—: ${moonriseStr}`;
            }
        }

        function updateWindForecastUI() {
            const canvas = document.getElementById('windChart');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            
            // Set canvas size properly
            const container = canvas.parentElement;
            canvas.width = container.offsetWidth;
            canvas.height = 150;
            
            if (currentData.windForecast.length === 0) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('××™×Ÿ × ×ª×•× ×™ ×ª×—×–×™×ª', canvas.width / 2, canvas.height / 2);
                return;
            }
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Data
            const hours = currentData.windForecast.map(f => f.hour.toString().padStart(2, '0') + ':00');
            const speeds = currentData.windForecast.map(f => f.speed);
            const maxSpeed = Math.max(...speeds, 30);
            const minSpeed = 0;
            
            // Chart dimensions
            const padding = { top: 20, right: 20, bottom: 30, left: 40 };
            const chartWidth = canvas.width - padding.left - padding.right;
            const chartHeight = canvas.height - padding.top - padding.bottom;
            
            // Draw grid lines and Y-axis labels
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.font = '11px Arial';
            ctx.lineWidth = 1;
            
            for (let i = 0; i <= 4; i++) {
                const y = padding.top + (chartHeight / 4) * i;
                const value = Math.round(maxSpeed - (maxSpeed / 4) * i);
                
                // Grid line
                ctx.beginPath();
                ctx.moveTo(padding.left, y);
                ctx.lineTo(padding.left + chartWidth, y);
                ctx.stroke();
                
                // Y-axis label
                ctx.textAlign = 'right';
                ctx.fillText(value, padding.left - 5, y + 4);
            }
            
            // Draw reference line at 15 km/h (optimal threshold)
            const optimalY = padding.top + chartHeight - ((15 / maxSpeed) * chartHeight);
            ctx.strokeStyle = 'rgba(16, 185, 129, 0.5)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(padding.left, optimalY);
            ctx.lineTo(padding.left + chartWidth, optimalY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw line chart
            const stepX = chartWidth / (speeds.length - 1);
            
            // Create gradient for area under curve
            const gradient = ctx.createLinearGradient(0, padding.top, 0, padding.top + chartHeight);
            gradient.addColorStop(0, 'rgba(96, 165, 250, 0.4)');
            gradient.addColorStop(1, 'rgba(96, 165, 250, 0.05)');
            
            // Draw filled area
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.moveTo(padding.left, padding.top + chartHeight);
            
            speeds.forEach((speed, index) => {
                const x = padding.left + stepX * index;
                const y = padding.top + chartHeight - ((speed / maxSpeed) * chartHeight);
                if (index === 0) {
                    ctx.lineTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            
            ctx.lineTo(padding.left + chartWidth, padding.top + chartHeight);
            ctx.closePath();
            ctx.fill();
            
            // Draw line
            ctx.strokeStyle = '#60a5fa';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            speeds.forEach((speed, index) => {
                const x = padding.left + stepX * index;
                const y = padding.top + chartHeight - ((speed / maxSpeed) * chartHeight);
                
                if (index === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            
            ctx.stroke();
            
            // Draw points
            speeds.forEach((speed, index) => {
                const x = padding.left + stepX * index;
                const y = padding.top + chartHeight - ((speed / maxSpeed) * chartHeight);
                
                // Determine color based on speed
                let color = '#10b981'; // Good
                if (speed > 25) color = '#ef4444'; // Poor
                else if (speed > 15) color = '#f59e0b'; // Moderate
                
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw value above point
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.font = 'bold 11px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(speed, x, y - 8);
            });
            
            // Draw X-axis labels
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            
            hours.forEach((hour, index) => {
                const x = padding.left + stepX * index;
                // Show every other label to avoid crowding
                if (index % 2 === 0 || hours.length <= 6) {
                    ctx.fillText(hour, x, canvas.height - 5);
                }
            });
        }

        function updateWaveForecastUI() {
            const canvas = document.getElementById('waveChart');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            
            // Set canvas size properly
            const container = canvas.parentElement;
            canvas.width = container.offsetWidth;
            canvas.height = 150;
            
            if (currentData.waveForecast.length === 0) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('××™×Ÿ × ×ª×•× ×™ ×ª×—×–×™×ª', canvas.width / 2, canvas.height / 2);
                return;
            }
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Data
            const hours = currentData.waveForecast.map(f => f.hour.toString().padStart(2, '0') + ':00');
            const heights = currentData.waveForecast.map(f => f.height);
            const maxHeight = Math.max(...heights, 2);
            const minHeight = 0;
            
            // Chart dimensions
            const padding = { top: 20, right: 20, bottom: 30, left: 40 };
            const chartWidth = canvas.width - padding.left - padding.right;
            const chartHeight = canvas.height - padding.top - padding.bottom;
            
            // Draw grid lines and Y-axis labels
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.font = '11px Arial';
            ctx.lineWidth = 1;
            
            for (let i = 0; i <= 4; i++) {
                const y = padding.top + (chartHeight / 4) * i;
                const value = (maxHeight - (maxHeight / 4) * i).toFixed(1);
                
                // Grid line
                ctx.beginPath();
                ctx.moveTo(padding.left, y);
                ctx.lineTo(padding.left + chartWidth, y);
                ctx.stroke();
                
                // Y-axis label
                ctx.textAlign = 'right';
                ctx.fillText(value + 'm', padding.left - 5, y + 4);
            }
            
            // Draw reference line at 0.5m (optimal threshold)
            const optimalY = padding.top + chartHeight - ((0.5 / maxHeight) * chartHeight);
            ctx.strokeStyle = 'rgba(16, 185, 129, 0.5)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(padding.left, optimalY);
            ctx.lineTo(padding.left + chartWidth, optimalY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw line chart
            const stepX = chartWidth / (heights.length - 1);
            
            // Create gradient for area under curve
            const gradient = ctx.createLinearGradient(0, padding.top, 0, padding.top + chartHeight);
            gradient.addColorStop(0, 'rgba(6, 182, 212, 0.4)');
            gradient.addColorStop(1, 'rgba(6, 182, 212, 0.05)');
            
            // Draw filled area
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.moveTo(padding.left, padding.top + chartHeight);
            
            heights.forEach((height, index) => {
                const x = padding.left + stepX * index;
                const y = padding.top + chartHeight - ((height / maxHeight) * chartHeight);
                if (index === 0) {
                    ctx.lineTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            
            ctx.lineTo(padding.left + chartWidth, padding.top + chartHeight);
            ctx.closePath();
            ctx.fill();
            
            // Draw line
            ctx.strokeStyle = '#06b6d4';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            heights.forEach((height, index) => {
                const x = padding.left + stepX * index;
                const y = padding.top + chartHeight - ((height / maxHeight) * chartHeight);
                
                if (index === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            
            ctx.stroke();
            
            // Draw points
            heights.forEach((height, index) => {
                const x = padding.left + stepX * index;
                const y = padding.top + chartHeight - ((height / maxHeight) * chartHeight);
                
                // Determine color based on height
                let color = '#10b981'; // Good
                if (height > 1.0) color = '#ef4444'; // Poor
                else if (height > 0.5) color = '#f59e0b'; // Moderate
                
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw value above point
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.font = 'bold 11px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(height.toFixed(2), x, y - 8);
            });
            
            // Draw X-axis labels
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            
            hours.forEach((hour, index) => {
                const x = padding.left + stepX * index;
                // Show every other label to avoid crowding
                if (index % 2 === 0 || hours.length <= 6) {
                    ctx.fillText(hour, x, canvas.height - 5);
                }
            });
        }

        function updateGPSUI() {
            if (currentData.gps !== null) {
                const gpsScore = calculateGPSScore(currentData.gps);
                document.getElementById('gpsData').textContent = currentData.gps === 0 ? '××™×Ÿ ×”×¤×¨×¢×•×ª' : `×¨××” ${currentData.gps}/10`;
                document.getElementById('gpsDetails').textContent = currentData.gps === 0 ? 'GPS ×¤×•×¢×œ ×ª×§×™×Ÿ' : currentData.gps < 5 ? '×”×¤×¨×¢×•×ª ×§×œ×•×ª' : '×”×¤×¨×¢×•×ª ××©××¢×•×ª×™×•×ª';
                document.getElementById('gpsQuality').textContent = getQualityText(gpsScore);
                document.getElementById('gpsQuality').className = `quality-indicator ${getQualityClass(gpsScore)}`;
            }
        }

        function updateTotalScore() {
            const score = calculateTotalScore();
            document.getElementById('totalScore').textContent = score;
            document.getElementById('statusText').textContent = getStatusText(score);
            
            // Update score container color based on score
            const container = document.querySelector('.score-container');
            if (score >= 85) {
                container.style.background = 'linear-gradient(135deg, #10b981 0%, #059669 100%)';
            } else if (score >= 70) {
                container.style.background = 'linear-gradient(135deg, #3b82f6 0%, #2563eb 100%)';
            } else if (score >= 55) {
                container.style.background = 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)';
            } else {
                container.style.background = 'linear-gradient(135deg, #ef4444 0%, #dc2626 100%)';
            }
        }

        async function loadAllData() {
            document.getElementById('statusText').textContent = '×˜×•×¢×Ÿ × ×ª×•× ×™×...';
            
            await Promise.all([
                fetchWeatherData(),
                fetchMoonData(),
                fetchGPSData(),
                fetchCatchReports()
            ]);
            
            updateTotalScore();
            
            const now = new Date();
            document.getElementById('updateTime').textContent = `×¢×“×›×•×Ÿ ××—×¨×•×Ÿ: ${now.toLocaleString('he-IL')}`;
        }

        function changeLocation() {
            const selectElement = document.getElementById('locationSelect');
            const selectedLocationKey = selectElement.value;
            
            // Update CONFIG with new location
            CONFIG.location = LOCATIONS[selectedLocationKey];
            
            // Update location info display
            updateLocationInfo();
            
            // Reload all data for new location
            loadAllData();
        }

        function updateLocationInfo() {
            const locationInfo = document.querySelector('.location-info strong');
            if (locationInfo) {
                locationInfo.textContent = `ğŸ“ ××–×•×¨: ${CONFIG.location.name}`;
            }
            
            // Update Windguru links based on location
            const windguruLinks = document.querySelector('.location-info div');
            if (windguruLinks && CONFIG.location.windguruId) {
                windguruLinks.innerHTML = `
                    <strong>ğŸŒŠ ×§×™×©×•×¨ ×œ×•×•×™× ×“×’×•×¨×•:</strong><br>
                    <a href="https://www.windguru.cz/${CONFIG.location.windguruId}" target="_blank" style="color: #ffd700; text-decoration: none;">${CONFIG.location.name} â†—</a>
                `;
            }
            
            // Update GPS map location marker
            updateGPSMapLocation();
        }

        function updateGPSMapLocation() {
            const locationName = CONFIG.location.name;
            const marker = document.getElementById('currentLocationMarker');
            
            if (!marker) return;
            
            // Map location names to Y coordinates on the map (SVG coordinates)
            const locationCoordinates = {
                '× ×ª× ×™×”-×—×“×¨×” (×›×œ×œ×™)': { y: 120 },
                '×‘×œ×• ×‘×™×™': { y: 145 },
                '××•×œ×’×” ×“×¨×•×': { y: 150 },
                '××•×œ×’×” ×¦×¤×•×Ÿ': { y: 140 },
                '××¨×’××Ÿ': { y: 160 },
                '×¨×¡×§×•': { y: 170 },
                '××¨×™× ×” ×”×¨×¦×œ×™×”': { y: 165 }
            };
            
            const coords = locationCoordinates[locationName] || { y: 135 };
            const x = 55; // Fixed X coordinate for coastline
            const y = coords.y;
            
            // Update marker position
            marker.innerHTML = `
                <circle cx="${x}" cy="${y}" r="4" fill="none" stroke="#10b981" stroke-width="2"/>
                <circle cx="${x}" cy="${y}" r="2" fill="#10b981"/>
            `;
        }

        // Auto-refresh every 10 minutes (only when authenticated)
        setInterval(() => {
            if (sessionStorage.getItem(SESSION_KEY) === 'true') {
                loadAllData();
            }
        }, 10 * 60 * 1000);

        function updateCloudForecastUI() {
            const canvas = document.getElementById('cloudChart');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            
            // Set canvas size properly
            const container = canvas.parentElement;
            canvas.width = container.offsetWidth;
            canvas.height = 150;
            
            if (currentData.cloudForecast.length === 0) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('××™×Ÿ × ×ª×•× ×™ ×ª×—×–×™×ª', canvas.width / 2, canvas.height / 2);
                return;
            }
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Data
            const hours = currentData.cloudForecast.map(f => f.hour.toString().padStart(2, '0') + ':00');
            const covers = currentData.cloudForecast.map(f => f.cover);
            
            // Chart dimensions
            const padding = { top: 20, right: 20, bottom: 30, left: 40 };
            const chartWidth = canvas.width - padding.left - padding.right;
            const chartHeight = canvas.height - padding.top - padding.bottom;
            
            // Draw grid lines and Y-axis labels
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.font = '11px Arial';
            ctx.lineWidth = 1;
            
            for (let i = 0; i <= 4; i++) {
                const y = padding.top + (chartHeight / 4) * i;
                const value = Math.round(100 - (100 / 4) * i);
                
                // Grid line
                ctx.beginPath();
                ctx.moveTo(padding.left, y);
                ctx.lineTo(padding.left + chartWidth, y);
                ctx.stroke();
                
                // Y-axis label
                ctx.textAlign = 'right';
                ctx.fillText(value + '%', padding.left - 5, y + 4);
            }
            
            // Draw reference line at 70% (good threshold for night fishing - clouds hide moon)
            const goodThresholdY = padding.top + chartHeight - ((70 / 100) * chartHeight);
            ctx.strokeStyle = 'rgba(16, 185, 129, 0.5)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(padding.left, goodThresholdY);
            ctx.lineTo(padding.left + chartWidth, goodThresholdY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw line chart
            const stepX = chartWidth / (covers.length - 1);
            
            // Create gradient for area under curve
            const gradient = ctx.createLinearGradient(0, padding.top, 0, padding.top + chartHeight);
            gradient.addColorStop(0, 'rgba(148, 163, 184, 0.4)');
            gradient.addColorStop(1, 'rgba(148, 163, 184, 0.05)');
            
            // Draw filled area
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.moveTo(padding.left, padding.top + chartHeight);
            
            covers.forEach((cover, index) => {
                const x = padding.left + stepX * index;
                const y = padding.top + chartHeight - ((cover / 100) * chartHeight);
                ctx.lineTo(x, y);
            });
            
            ctx.lineTo(padding.left + chartWidth, padding.top + chartHeight);
            ctx.closePath();
            ctx.fill();
            
            // Draw line
            ctx.strokeStyle = '#94a3b8';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            covers.forEach((cover, index) => {
                const x = padding.left + stepX * index;
                const y = padding.top + chartHeight - ((cover / 100) * chartHeight);
                
                if (index === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            
            ctx.stroke();
            
            // Draw points
            covers.forEach((cover, index) => {
                const x = padding.left + stepX * index;
                const y = padding.top + chartHeight - ((cover / 100) * chartHeight);
                
                // Determine color based on cover (for night fishing, more clouds is better)
                let color = '#10b981'; // Good (high clouds at night hide moon)
                if (cover < 30) color = '#ef4444'; // Poor (clear sky = bright moon)
                else if (cover < 70) color = '#f59e0b'; // Moderate
                
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw value above point
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.font = 'bold 11px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(Math.round(cover) + '%', x, y - 8);
            });
            
            // Draw X-axis labels
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            
            hours.forEach((hour, index) => {
                const x = padding.left + stepX * index;
                // Show every other label to avoid crowding
                if (index % 2 === 0 || hours.length <= 6) {
                    ctx.fillText(hour, x, canvas.height - 5);
                }
            });
        }

        // Chart instances
        let windChart = null;
        let waveChart = null;
        let currentCatchTab = '24h';
        let currentCatchMethod = 'beachDrone'; // Default to drone fishing

        function switchCatchMethod(method) {
            // Update method buttons
            document.querySelectorAll('.method-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.closest('.method-btn').classList.add('active');
            
            currentCatchMethod = method;
            updateCatchReportsUI();
        }

        function switchCatchTab(period) {
            // Update tabs
            document.querySelectorAll('.catch-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Update stats display
            document.getElementById('catchStats24h').style.display = period === '24h' ? 'grid' : 'none';
            document.getElementById('catchStats48h').style.display = period === '48h' ? 'grid' : 'none';
            document.getElementById('catchStats72h').style.display = period === '72h' ? 'grid' : 'none';
            
            currentCatchTab = period;
            updateCatchReportsUI();
        }

        async function fetchCatchReports() {
            /* 
            IMPORTANT: This function requires social media API integration
            
            For Facebook:
            - Requires Facebook Graph API access
            - Need to create a Facebook App
            - Get Page Access Token
            - Search for posts with hashtags related to fishing locations
            - Keywords: "×“×™×’ ×‘×›×£", location names, "×ª×¤×™×¡×”", "fish caught"
            
            For Instagram:
            - Requires Instagram Basic Display API or Instagram Graph API
            - Similar hashtag/location search
            - Parse posts for catch reports
            
            Alternative approach (Manual Entry):
            - Create a simple form where fishermen can report catches
            - Store in Firebase/Supabase
            - Display aggregated statistics
            
            Below is a MOCK implementation for demonstration.
            Replace with actual API calls when ready.
            */
            
            try {
                // MOCK DATA - Replace with actual API calls
                const locationKey = CONFIG.location.name;
                
                // Simulate API call delay
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Mock data based on location and randomness
                const mockData = generateMockCatchData(locationKey);
                
                currentData.catchReports = mockData;
                updateCatchReportsUI();
                
            } catch (error) {
                console.error('Error fetching catch reports:', error);
                // Display error state
                document.getElementById('total24h').textContent = '--';
                document.getElementById('successful24h').textContent = '--';
                document.getElementById('successRate24h').textContent = '--';
            }
        }

        function generateMockCatchData(location) {
            // Mock data generator - replace with real API data
            // Generate different patterns for each fishing method
            
            // Beach Drone - typically fewer reports but higher success rate
            const droneMock = {
                last24h: {
                    total: Math.floor(Math.random() * 12) + 3,
                    successful: 0,
                    species: {
                        '×“× ×™×¡': Math.floor(Math.random() * 5) + 1,
                        '×œ×•×§×•×¡': Math.floor(Math.random() * 4) + 1,
                        '×‘×•×¨×™': Math.floor(Math.random() * 3) + 1
                    }
                },
                last48h: {
                    total: Math.floor(Math.random() * 20) + 6,
                    successful: 0,
                    species: {
                        '×“× ×™×¡': Math.floor(Math.random() * 8) + 2,
                        '×œ×•×§×•×¡': Math.floor(Math.random() * 6) + 1,
                        '×‘×•×¨×™': Math.floor(Math.random() * 5) + 1
                    }
                },
                last72h: {
                    total: Math.floor(Math.random() * 28) + 10,
                    successful: 0,
                    species: {
                        '×“× ×™×¡': Math.floor(Math.random() * 10) + 3,
                        '×œ×•×§×•×¡': Math.floor(Math.random() * 8) + 2,
                        '×‘×•×¨×™': Math.floor(Math.random() * 7) + 2
                    }
                }
            };
            
            // Beach Surf - more reports, medium success rate
            const surfMock = {
                last24h: {
                    total: Math.floor(Math.random() * 18) + 5,
                    successful: 0,
                    species: {
                        '×‘×•×¨×™': Math.floor(Math.random() * 6) + 2,
                        '×¡×¨×’×•×¡': Math.floor(Math.random() * 5) + 1,
                        '×“× ×™×¡': Math.floor(Math.random() * 4) + 1,
                        '×—× ×•×Ÿ': Math.floor(Math.random() * 3) + 1
                    }
                },
                last48h: {
                    total: Math.floor(Math.random() * 30) + 10,
                    successful: 0,
                    species: {
                        '×‘×•×¨×™': Math.floor(Math.random() * 10) + 3,
                        '×¡×¨×’×•×¡': Math.floor(Math.random() * 8) + 2,
                        '×“× ×™×¡': Math.floor(Math.random() * 6) + 2,
                        '×—× ×•×Ÿ': Math.floor(Math.random() * 5) + 1
                    }
                },
                last72h: {
                    total: Math.floor(Math.random() * 45) + 15,
                    successful: 0,
                    species: {
                        '×‘×•×¨×™': Math.floor(Math.random() * 15) + 4,
                        '×¡×¨×’×•×¡': Math.floor(Math.random() * 12) + 3,
                        '×“× ×™×¡': Math.floor(Math.random() * 10) + 3,
                        '×—× ×•×Ÿ': Math.floor(Math.random() * 8) + 2
                    }
                }
            };
            
            // Boat - highest catches, different species
            const boatMock = {
                last24h: {
                    total: Math.floor(Math.random() * 10) + 2,
                    successful: 0,
                    species: {
                        '×˜×•× ×”': Math.floor(Math.random() * 3) + 1,
                        '×œ×•×§×•×¡': Math.floor(Math.random() * 4) + 1,
                        '×“× ×™×¡': Math.floor(Math.random() * 3) + 1,
                        '×‘×¨×§×•×“×”': Math.floor(Math.random() * 2) + 1
                    }
                },
                last48h: {
                    total: Math.floor(Math.random() * 18) + 4,
                    successful: 0,
                    species: {
                        '×˜×•× ×”': Math.floor(Math.random() * 5) + 2,
                        '×œ×•×§×•×¡': Math.floor(Math.random() * 6) + 2,
                        '×“× ×™×¡': Math.floor(Math.random() * 5) + 1,
                        '×‘×¨×§×•×“×”': Math.floor(Math.random() * 4) + 1
                    }
                },
                last72h: {
                    total: Math.floor(Math.random() * 25) + 8,
                    successful: 0,
                    species: {
                        '×˜×•× ×”': Math.floor(Math.random() * 8) + 3,
                        '×œ×•×§×•×¡': Math.floor(Math.random() * 10) + 3,
                        '×“× ×™×¡': Math.floor(Math.random() * 8) + 2,
                        '×‘×¨×§×•×“×”': Math.floor(Math.random() * 6) + 2
                    }
                }
            };
            
            // Calculate success rates (drone highest, then boat, then surf)
            droneMock.last24h.successful = Math.floor(droneMock.last24h.total * (0.55 + Math.random() * 0.25));
            droneMock.last48h.successful = Math.floor(droneMock.last48h.total * (0.55 + Math.random() * 0.25));
            droneMock.last72h.successful = Math.floor(droneMock.last72h.total * (0.55 + Math.random() * 0.25));
            
            surfMock.last24h.successful = Math.floor(surfMock.last24h.total * (0.35 + Math.random() * 0.25));
            surfMock.last48h.successful = Math.floor(surfMock.last48h.total * (0.35 + Math.random() * 0.25));
            surfMock.last72h.successful = Math.floor(surfMock.last72h.total * (0.35 + Math.random() * 0.25));
            
            boatMock.last24h.successful = Math.floor(boatMock.last24h.total * (0.45 + Math.random() * 0.25));
            boatMock.last48h.successful = Math.floor(boatMock.last48h.total * (0.45 + Math.random() * 0.25));
            boatMock.last72h.successful = Math.floor(boatMock.last72h.total * (0.45 + Math.random() * 0.25));
            
            // Generate weekly trends (7 days back from today)
            const weeklyTrends = {
                dates: [],
                beachDrone: [],
                beachSurf: [],
                boat: []
            };
            
            const today = new Date();
            for (let i = 6; i >= 0; i--) {
                const date = new Date(today);
                date.setDate(date.getDate() - i);
                
                // Format date as DD/MM
                const day = date.getDate().toString().padStart(2, '0');
                const month = (date.getMonth() + 1).toString().padStart(2, '0');
                weeklyTrends.dates.push(`${day}/${month}`);
                
                // Generate realistic trends with some patterns
                // Weekend typically has more catches
                const isWeekend = date.getDay() === 5 || date.getDay() === 6; // Friday/Saturday
                const weekendBonus = isWeekend ? 1.3 : 1.0;
                
                // Drone: moderate numbers, consistent
                weeklyTrends.beachDrone.push(Math.floor((Math.random() * 4 + 2) * weekendBonus));
                
                // Surf: higher numbers, more variable
                weeklyTrends.beachSurf.push(Math.floor((Math.random() * 8 + 3) * weekendBonus));
                
                // Boat: lower numbers, weather dependent
                weeklyTrends.boat.push(Math.floor((Math.random() * 3 + 1) * weekendBonus));
            }
            
            return {
                last24h: { beachSurf: surfMock.last24h, beachDrone: droneMock.last24h, boat: boatMock.last24h },
                last48h: { beachSurf: surfMock.last48h, beachDrone: droneMock.last48h, boat: boatMock.last48h },
                last72h: { beachSurf: surfMock.last72h, beachDrone: droneMock.last72h, boat: boatMock.last72h },
                weeklyTrends: weeklyTrends
            };
        }

        function updateCatchReportsUI() {
            const data = currentData.catchReports;
            const method = currentCatchMethod;
            
            // 24h stats
            const data24h = data.last24h[method];
            document.getElementById('total24h').textContent = data24h.total;
            document.getElementById('successful24h').textContent = data24h.successful;
            const rate24h = data24h.total > 0 
                ? Math.round((data24h.successful / data24h.total) * 100) 
                : 0;
            document.getElementById('successRate24h').textContent = rate24h + '%';
            
            // 48h stats
            const data48h = data.last48h[method];
            document.getElementById('total48h').textContent = data48h.total;
            document.getElementById('successful48h').textContent = data48h.successful;
            const rate48h = data48h.total > 0 
                ? Math.round((data48h.successful / data48h.total) * 100) 
                : 0;
            document.getElementById('successRate48h').textContent = rate48h + '%';
            
            // 72h stats
            const data72h = data.last72h[method];
            document.getElementById('total72h').textContent = data72h.total;
            document.getElementById('successful72h').textContent = data72h.successful;
            const rate72h = data72h.total > 0 
                ? Math.round((data72h.successful / data72h.total) * 100) 
                : 0;
            document.getElementById('successRate72h').textContent = rate72h + '%';
            
            updateCatchSpeciesDisplay();
            updateWeeklyTrendsChart();
        }

        function updateCatchSpeciesDisplay() {
            const period = currentCatchTab;
            const method = currentCatchMethod;
            const periodKey = period === '24h' ? 'last24h' : period === '48h' ? 'last48h' : 'last72h';
            const species = currentData.catchReports[periodKey][method].species;
            
            const speciesList = document.getElementById('speciesList');
            
            if (Object.keys(species).length === 0) {
                speciesList.innerHTML = '<div style="color: #64748b;">××™×Ÿ ×“×™×•×•×—×™ ××™× ×™×</div>';
                return;
            }
            
            let html = '';
            Object.entries(species)
                .sort((a, b) => b[1] - a[1])
                .forEach(([name, count]) => {
                    html += `
                        <div class="species-badge">
                            <span>${name}</span>
                            <span class="species-count">${count}</span>
                        </div>
                    `;
                });
            
            speciesList.innerHTML = html;
        }

        function updateWeeklyTrendsChart() {
            const canvas = document.getElementById('weeklyTrendsChart');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            
            // Set canvas size properly
            const container = canvas.parentElement;
            canvas.width = container.offsetWidth;
            canvas.height = 200;
            
            const trends = currentData.catchReports.weeklyTrends;
            
            if (trends.dates.length === 0) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('××™×Ÿ × ×ª×•× ×™ ××’××•×ª', canvas.width / 2, canvas.height / 2);
                return;
            }
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Data
            const dates = trends.dates;
            const maxCatches = Math.max(
                ...trends.beachDrone,
                ...trends.beachSurf,
                ...trends.boat,
                10
            );
            
            // Chart dimensions
            const padding = { top: 20, right: 20, bottom: 40, left: 40 };
            const chartWidth = canvas.width - padding.left - padding.right;
            const chartHeight = canvas.height - padding.top - padding.bottom;
            
            // Draw grid lines and Y-axis labels
            ctx.strokeStyle = 'rgba(100, 116, 139, 0.2)';
            ctx.fillStyle = 'rgba(148, 163, 184, 0.8)';
            ctx.font = '11px Arial';
            ctx.lineWidth = 1;
            
            const ySteps = 5;
            for (let i = 0; i <= ySteps; i++) {
                const y = padding.top + (chartHeight / ySteps) * i;
                const value = Math.round(maxCatches - (maxCatches / ySteps) * i);
                
                // Grid line
                ctx.beginPath();
                ctx.moveTo(padding.left, y);
                ctx.lineTo(padding.left + chartWidth, y);
                ctx.stroke();
                
                // Y-axis label
                ctx.textAlign = 'right';
                ctx.fillText(value, padding.left - 5, y + 4);
            }
            
            // Calculate step for X axis
            const stepX = chartWidth / (dates.length - 1);
            
            // Function to draw a line
            function drawLine(data, color, lineWidth = 2.5) {
                ctx.strokeStyle = color;
                ctx.lineWidth = lineWidth;
                ctx.beginPath();
                
                data.forEach((value, index) => {
                    const x = padding.left + stepX * index;
                    const y = padding.top + chartHeight - ((value / maxCatches) * chartHeight);
                    
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                
                ctx.stroke();
                
                // Draw points
                data.forEach((value, index) => {
                    const x = padding.left + stepX * index;
                    const y = padding.top + chartHeight - ((value / maxCatches) * chartHeight);
                    
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw stroke around point for better visibility
                    ctx.strokeStyle = '#0f172a';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                });
            }
            
            // Draw all three lines
            drawLine(trends.beachDrone, '#60a5fa', 3); // Blue - Drone
            drawLine(trends.beachSurf, '#10b981', 3);  // Green - Surf
            drawLine(trends.boat, '#f59e0b', 3);       // Orange - Boat
            
            // Draw X-axis labels (dates)
            ctx.fillStyle = 'rgba(203, 213, 225, 0.9)';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            
            dates.forEach((date, index) => {
                const x = padding.left + stepX * index;
                ctx.fillText(date, x, canvas.height - 10);
            });
            
            // Draw Y-axis label
            ctx.save();
            ctx.translate(15, canvas.height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillStyle = 'rgba(148, 163, 184, 0.8)';
            ctx.font = '11px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('×ª×¤×™×¡×•×ª ××•×¦×œ×—×•×ª', 0, 0);
            ctx.restore();
        }
    </script>
</body>
</html>
