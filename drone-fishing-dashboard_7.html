<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>×”×¨×—×¤× ×™×¡×˜×™× - ×ª× ××™ ×“×™×’ ×‘×›×£ | Drone Fishing Conditions</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0e1a;
            color: #e2e8f0;
            padding: 0;
            margin: 0;
            min-height: 100vh;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 30px 20px;
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            border-bottom: 1px solid rgba(100, 116, 139, 0.2);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        h1 {
            font-size: 2.2em;
            margin-bottom: 12px;
            font-weight: 700;
            background: linear-gradient(135deg, #60a5fa 0%, #3b82f6 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            font-size: 1em;
            color: #94a3b8;
            font-weight: 400;
        }

        .score-container {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            padding: 40px;
            border-radius: 16px;
            text-align: center;
            margin-bottom: 30px;
            border: 1px solid rgba(100, 116, 139, 0.3);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
            position: relative;
            overflow: hidden;
        }

        .score-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #3b82f6 0%, #60a5fa 50%, #3b82f6 100%);
            animation: shimmer 3s ease-in-out infinite;
        }

        @keyframes shimmer {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.5; }
            50% { transform: scale(1.1); opacity: 0.3; }
        }

        .score-value {
            font-size: 4.5em;
            font-weight: 700;
            margin: 20px 0;
            position: relative;
            z-index: 1;
            letter-spacing: -2px;
        }

        .score-label {
            font-size: 1.1em;
            color: #94a3b8;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-weight: 600;
            position: relative;
            z-index: 1;
        }

        .status-text {
            font-size: 1.5em;
            margin-top: 15px;
            font-weight: 600;
            position: relative;
            z-index: 1;
        }

        .data-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }

        .data-card {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            border: 1px solid rgba(100, 116, 139, 0.3);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
        }

        .data-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
            border-color: rgba(100, 116, 139, 0.5);
        }

        .card-title {
            font-size: 1em;
            margin-bottom: 12px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(100, 116, 139, 0.2);
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
            color: #cbd5e1;
        }

        .card-icon {
            font-size: 1.4em;
        }

        .card-content {
            font-size: 1.8em;
            font-weight: 700;
            margin: 15px 0;
            text-align: center;
            color: #f1f5f9;
        }

        .card-details {
            font-size: 0.85em;
            color: #94a3b8;
            line-height: 1.5;
        }

        .quality-indicator {
            display: inline-block;
            padding: 6px 14px;
            border-radius: 6px;
            font-size: 0.75em;
            font-weight: 600;
            margin-top: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .excellent { 
            background: rgba(16, 185, 129, 0.2);
            color: #10b981;
            border: 1px solid rgba(16, 185, 129, 0.3);
        }
        .good { 
            background: rgba(59, 130, 246, 0.2);
            color: #3b82f6;
            border: 1px solid rgba(59, 130, 246, 0.3);
        }
        .moderate { 
            background: rgba(245, 158, 11, 0.2);
            color: #f59e0b;
            border: 1px solid rgba(245, 158, 11, 0.3);
        }
        .poor { 
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
            border: 1px solid rgba(239, 68, 68, 0.3);
        }

        .update-time {
            text-align: center;
            margin-top: 30px;
            padding: 15px;
            background: #1e293b;
            border-radius: 8px;
            font-size: 0.85em;
            color: #94a3b8;
            border: 1px solid rgba(100, 116, 139, 0.2);
        }

        .loading {
            text-align: center;
            padding: 40px;
            font-size: 1.2em;
        }

        .error {
            background: rgba(239, 68, 68, 0.15);
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            border-left: 3px solid #ef4444;
            color: #fca5a5;
        }

        .location-info {
            background: #1e293b;
            padding: 16px;
            border-radius: 12px;
            margin-bottom: 20px;
            text-align: center;
            font-size: 0.9em;
            border: 1px solid rgba(100, 116, 139, 0.2);
            color: #cbd5e1;
        }

        .location-info a {
            color: #60a5fa;
            text-decoration: none;
            transition: color 0.2s;
        }

        .location-info a:hover {
            color: #93c5fd;
        }

        @media (max-width: 768px) {
            body {
                padding: 5px;
            }
            
            h1 { 
                font-size: 1.5em; 
            }
            
            .subtitle {
                font-size: 0.8em;
            }
            
            .score-value { 
                font-size: 2.8em; 
            }
            
            .status-text {
                font-size: 1em;
            }
            
            .data-grid { 
                grid-template-columns: repeat(2, 1fr);
                gap: 8px;
            }
            
            .card-title {
                font-size: 0.9em;
            }
            
            .card-content {
                font-size: 1.2em;
            }
            
            .card-details {
                font-size: 0.75em;
            }
            
            header {
                padding: 10px;
                margin-bottom: 10px;
            }
            
            .location-info {
                font-size: 0.75em;
                padding: 10px;
            }
        }

        @media (max-width: 480px) {
            .card-content {
                font-size: 1.1em;
            }
            
            .card-details {
                font-size: 0.7em;
            }
            
            .direction-arrow {
                width: 45px;
                height: 45px;
            }
            
            .moon-visual {
                width: 60px;
                height: 60px;
            }
        }

        @media (min-width: 769px) {
            .data-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        .refresh-btn {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            border: none;
            color: white;
            padding: 12px 28px;
            border-radius: 8px;
            font-size: 0.95em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 15px;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        }

        .refresh-btn:hover {
            background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
            transform: translateY(-1px);
            box-shadow: 0 6px 16px rgba(59, 130, 246, 0.4);
        }

        .location-selector {
            margin: 15px 0 10px 0;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            flex-wrap: wrap;
        }

        .location-selector label {
            font-size: 0.95em;
            font-weight: 600;
            color: #cbd5e1;
        }

        .location-dropdown {
            background: #0f172a;
            border: 1px solid rgba(100, 116, 139, 0.3);
            color: #e2e8f0;
            padding: 10px 16px;
            border-radius: 8px;
            font-size: 0.95em;
            cursor: pointer;
            transition: all 0.3s;
            min-width: 200px;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        .location-dropdown:hover {
            background: #1e293b;
            border-color: rgba(100, 116, 139, 0.5);
        }

        .location-dropdown:focus {
            outline: none;
            background: #1e293b;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .location-dropdown option {
            background: #0f172a;
            color: #e2e8f0;
            padding: 10px;
        }

        @media (max-width: 480px) {
            .location-selector {
                flex-direction: column;
                gap: 8px;
            }
            
            .location-dropdown {
                min-width: 180px;
                font-size: 0.9em;
                padding: 8px 12px;
            }
        }

        .moon-phase-icon {
            font-size: 3em;
            margin: 10px 0;
        }

        .direction-arrow {
            display: inline-block;
            width: 50px;
            height: 50px;
            margin: 8px auto;
            position: relative;
        }

        .arrow-svg {
            width: 100%;
            height: 100%;
            filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3));
        }

        .direction-label {
            text-align: center;
            font-size: 0.85em;
            font-weight: bold;
            margin-top: 3px;
            color: #60a5fa;
        }

        .direction-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 8px 0;
        }

        .moon-visual {
            width: 65px;
            height: 65px;
            margin: 10px auto;
            position: relative;
            background: #1a1a2e;
            border-radius: 50%;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
            overflow: hidden;
        }

        .moon-circle {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            position: relative;
            background: linear-gradient(90deg, #1a1a2e 50%, #f0f0f0 50%);
        }

        .moon-overlay {
            position: absolute;
            top: 0;
            width: 50%;
            height: 100%;
            background: #f0f0f0;
            border-radius: 50%;
        }

        .moon-shadow {
            position: absolute;
            top: 0;
            width: 50%;
            height: 100%;
            background: #1a1a2e;
            border-radius: 50%;
        }

        .time-info {
            font-size: 0.75em;
            margin-top: 5px;
            line-height: 1.5;
        }

        .wind-card {
            grid-column: span 2;
        }

        .wave-card {
            grid-column: span 2;
        }

        .cloud-card {
            grid-column: span 2;
        }

        .wind-current {
            border-bottom: 1px solid rgba(255,255,255,0.2);
            padding-bottom: 10px;
            margin-bottom: 10px;
        }

        .wave-current {
            border-bottom: 1px solid rgba(255,255,255,0.2);
            padding-bottom: 10px;
            margin-bottom: 10px;
        }

        .cloud-current {
            border-bottom: 1px solid rgba(255,255,255,0.2);
            padding-bottom: 10px;
            margin-bottom: 10px;
        }

        .current-label {
            font-size: 0.8em;
            font-weight: 600;
            color: #60a5fa;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .forecast-label {
            font-size: 0.8em;
            font-weight: 600;
            color: #60a5fa;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .forecast-timeline {
            display: flex;
            gap: 8px;
            overflow-x: auto;
            padding: 5px 0;
            scrollbar-width: thin;
            scrollbar-color: rgba(255,255,255,0.3) rgba(255,255,255,0.1);
        }

        .forecast-timeline::-webkit-scrollbar {
            height: 4px;
        }

        .forecast-timeline::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
        }

        .forecast-timeline::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.3);
            border-radius: 2px;
        }

        .forecast-hour {
            flex: 0 0 auto;
            min-width: 80px;
            text-align: center;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            padding: 10px 6px;
            font-size: 0.8em;
        }

        .forecast-time {
            font-weight: bold;
            margin-bottom: 6px;
            color: #ffd700;
            font-size: 1.1em;
        }

        .forecast-speed {
            font-size: 1.3em;
            font-weight: bold;
            margin: 4px 0;
        }

        .forecast-dir {
            font-size: 0.85em;
            opacity: 0.9;
            margin-top: 2px;
        }

        .forecast-arrow {
            width: 28px;
            height: 28px;
            margin: 4px auto;
        }

        @media (max-width: 768px) {
            .wind-card {
                grid-column: span 2;
            }
            
            .wave-card {
                grid-column: span 2;
            }
            
            .cloud-card {
                grid-column: span 2;
            }
            
            .forecast-hour {
                min-width: 70px;
                padding: 8px 5px;
                font-size: 0.75em;
            }
            
            .forecast-arrow {
                width: 24px;
                height: 24px;
            }
        }

        @media (min-width: 769px) {
            .wind-card {
                grid-column: span 3;
            }
            
            .wave-card {
                grid-column: span 3;
            }
            
            .cloud-card {
                grid-column: span 3;
            }
        }

        /* Password Login Styles */
        .login-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0a0e1a;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }

        .login-container {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            border: 1px solid rgba(100, 116, 139, 0.3);
            border-radius: 16px;
            padding: 50px 40px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.6);
            text-align: center;
            max-width: 420px;
            width: 90%;
        }

        .login-title {
            font-size: 2.2em;
            margin-bottom: 12px;
            font-weight: 700;
            background: linear-gradient(135deg, #60a5fa 0%, #3b82f6 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .login-subtitle {
            font-size: 1.1em;
            margin-bottom: 35px;
            color: #94a3b8;
            font-weight: 400;
        }

        .login-input {
            width: 100%;
            padding: 16px;
            border: 1px solid rgba(100, 116, 139, 0.3);
            border-radius: 8px;
            background: #0f172a;
            color: #e2e8f0;
            font-size: 1em;
            text-align: center;
            margin-bottom: 20px;
            transition: all 0.3s;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        .login-input:focus {
            outline: none;
            border-color: #3b82f6;
            background: #1e293b;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .login-input::placeholder {
            color: #64748b;
        }

        .login-btn {
            width: 100%;
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            border: none;
            color: white;
            padding: 16px 30px;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        }

        .login-btn:hover {
            background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
            transform: translateY(-1px);
            box-shadow: 0 6px 16px rgba(59, 130, 246, 0.4);
        }

        .login-error {
            background: rgba(239, 68, 68, 0.15);
            border: 1px solid rgba(239, 68, 68, 0.3);
            color: #fca5a5;
            padding: 14px;
            border-radius: 8px;
            margin-top: 18px;
            display: none;
            font-size: 0.9em;
        }

        .login-icon {
            font-size: 4em;
            margin-bottom: 20px;
        }

        @media (max-width: 480px) {
            .login-container {
                padding: 30px 20px;
            }
            
            .login-title {
                font-size: 1.6em;
            }
            
            .login-subtitle {
                font-size: 1em;
            }
        }
    </style>
</head>
<body>
    <!-- Password Login Overlay -->
    <div class="login-overlay" id="loginOverlay">
        <div class="login-container">
            <div class="login-icon">ğŸ£</div>
            <h2 class="login-title">×”×¨×—×¤× ×™×¡×˜×™×</h2>
            <p class="login-subtitle">××¢×¨×›×ª × ×™×˜×•×¨ ×ª× ××™ ×“×™×’</p>
            <input 
                type="password" 
                id="passwordInput" 
                class="login-input" 
                placeholder="×”×–×Ÿ ×¡×™×¡××”"
                onkeypress="handlePasswordKeypress(event)"
            >
            <button class="login-btn" onclick="checkPassword()">×›× ×™×¡×”</button>
            <div class="login-error" id="loginError">
                âŒ ×¡×™×¡××” ×©×’×•×™×”. × ×¡×” ×©×•×‘.
            </div>
        </div>
    </div>

    <div class="container" id="mainContent" style="display: none;">
        <header>
            <h1>ğŸ£ ×”×¨×—×¤× ×™×¡×˜×™× - ××¢×¨×›×ª × ×™×˜×•×¨ ×ª× ××™×</h1>
            <div class="subtitle">××¨×—×§ 400-800 ××˜×¨ ××”×—×•×£</div>
            
            <div class="location-selector">
                <label for="locationSelect">×‘×—×¨ ××–×•×¨:</label>
                <select id="locationSelect" class="location-dropdown" onchange="changeLocation()">
                    <option value="netanya-hadera">× ×ª× ×™×”-×—×“×¨×” (×›×œ×œ×™)</option>
                    <option value="blue-bay">×‘×œ×• ×‘×™×™</option>
                    <option value="olga-south">××•×œ×’×” ×“×¨×•×</option>
                    <option value="olga-north">××•×œ×’×” ×¦×¤×•×Ÿ</option>
                    <option value="argaman">××¨×’××Ÿ</option>
                    <option value="rasco">×¨×¡×§×•</option>
                    <option value="herzliya-marina">××¨×™× ×” ×”×¨×¦×œ×™×”</option>
                </select>
            </div>
            
            <button class="refresh-btn" onclick="loadAllData()">ğŸ”„ ×¨×¢× ×•×Ÿ × ×ª×•× ×™×</button>
        </header>

        <div class="location-info">
            <strong>ğŸ“ ××–×•×¨: × ×ª× ×™×”-×—×“×¨×” (×›×œ×œ×™)</strong> | ××¨×—×§ 400-800 ××˜×¨ ××”×—×•×£
            <div style="margin-top: 10px; font-size: 0.9em;">
                <strong>ğŸŒŠ ×§×™×©×•×¨ ×œ×•×•×™× ×“×’×•×¨×•:</strong><br>
                <a href="https://www.windguru.cz/10172" target="_blank" style="color: #ffd700; text-decoration: none;">× ×ª× ×™×”-×—×“×¨×” â†—</a>
            </div>
        </div>

        <div class="score-container">
            <div class="score-label">×“×™×¨×•×’ ×ª× ××™ ×“×™×’</div>
            <div class="score-value" id="totalScore">--</div>
            <div class="status-text" id="statusText">×˜×•×¢×Ÿ × ×ª×•× ×™×...</div>
        </div>

        <div class="data-grid">
            <!-- Wind Data -->
            <div class="data-card wind-card">
                <div class="card-title">
                    <span class="card-icon">ğŸŒ¬ï¸</span>
                    <span>×¨×•×—</span>
                </div>
                <div class="wind-current">
                    <div class="current-label">×›×¢×ª:</div>
                    <div class="direction-container">
                        <div class="direction-arrow" id="windArrow">
                            <svg class="arrow-svg" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                                <defs>
                                    <linearGradient id="windGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                                        <stop offset="0%" style="stop-color:#60a5fa;stop-opacity:1" />
                                        <stop offset="100%" style="stop-color:#3b82f6;stop-opacity:1" />
                                    </linearGradient>
                                </defs>
                                <g transform="rotate(0 50 50)" id="windArrowGroup">
                                    <path d="M 50 10 L 65 40 L 55 40 L 55 90 L 45 90 L 45 40 L 35 40 Z" 
                                          fill="url(#windGradient)" 
                                          stroke="#1e40af" 
                                          stroke-width="2"/>
                                </g>
                            </svg>
                        </div>
                        <div class="direction-label" id="windDirectionLabel">--</div>
                    </div>
                    <div class="card-content" id="windData">--</div>
                    <div class="card-details" id="windDetails">×˜×•×¢×Ÿ...</div>
                </div>
                <div class="wind-forecast" id="windForecast">
                    <div class="forecast-label">×ª×—×–×™×ª 14:00-00:00 (km/h):</div>
                    <canvas id="windChart" style="width: 100%; height: 150px;"></canvas>
                </div>
                <div class="quality-indicator" id="windQuality">--</div>
            </div>

            <!-- Wave Data -->
            <div class="data-card wave-card">
                <div class="card-title">
                    <span class="card-icon">ğŸŒŠ</span>
                    <span>×’×œ×™×</span>
                </div>
                <div class="wave-current">
                    <div class="current-label">×›×¢×ª:</div>
                    <div class="card-content" id="waveData">--</div>
                    <div class="card-details" id="waveDetails">×˜×•×¢×Ÿ...</div>
                </div>
                <div class="wave-forecast" id="waveForecast">
                    <div class="forecast-label">×ª×—×–×™×ª 14:00-00:00 (××˜×¨×™×):</div>
                    <canvas id="waveChart" style="width: 100%; height: 150px;"></canvas>
                </div>
                <div class="quality-indicator" id="waveQuality">--</div>
            </div>

            <!-- GPS Interference -->
            <div class="data-card">
                <div class="card-title">
                    <span class="card-icon">ğŸ“¡</span>
                    <span>×”×¤×¨×¢×•×ª GPS</span>
                </div>
                <div class="card-content" id="gpsData">--</div>
                <div class="card-details" id="gpsDetails">×˜×•×¢×Ÿ...</div>
                <div class="quality-indicator" id="gpsQuality">--</div>
            </div>

            <!-- Moon Phase -->
            <div class="data-card">
                <div class="card-title">
                    <span class="card-icon">ğŸŒ™</span>
                    <span>×™×¨×—</span>
                </div>
                <div class="moon-visual" id="moonVisual">
                    <svg width="65" height="65" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                        <!-- Dark background (night sky) -->
                        <circle cx="50" cy="50" r="48" fill="#1a1a2e"/>
                        
                        <!-- Illuminated moon surface -->
                        <circle cx="50" cy="50" r="45" fill="#f0f0f0" id="moonBase"/>
                        
                        <!-- Shadow overlay -->
                        <ellipse cx="50" cy="50" rx="45" ry="45" fill="#1a1a2e" id="moonShadow" transform="translate(0,0)"/>
                        
                        <!-- Moon craters for realism -->
                        <circle cx="40" cy="40" r="5" fill="#d0d0d0" opacity="0.5"/>
                        <circle cx="60" cy="45" r="7" fill="#d0d0d0" opacity="0.5"/>
                        <circle cx="50" cy="60" r="4" fill="#d0d0d0" opacity="0.5"/>
                    </svg>
                </div>
                <div class="card-content" id="moonData">--</div>
                <div class="card-details" id="moonDetails">×˜×•×¢×Ÿ...</div>
                <div class="card-details" id="sunTimes" style="margin-top: 8px; border-top: 1px solid rgba(255,255,255,0.2); padding-top: 6px;">
                    ğŸŒ… <span id="sunsetTime">--</span><br>
                    ğŸŒ† <span id="duskTime">--</span>
                </div>
                <div class="quality-indicator" id="moonQuality">--</div>
            </div>

            <!-- Cloud Cover -->
            <div class="data-card cloud-card">
                <div class="card-title">
                    <span class="card-icon">â˜ï¸</span>
                    <span>×¢× × ×•×ª</span>
                </div>
                <div class="cloud-current">
                    <div class="current-label">×›×¢×ª:</div>
                    <div class="card-content" id="cloudData">--</div>
                    <div class="card-details" id="cloudDetails">×˜×•×¢×Ÿ...</div>
                </div>
                <div class="cloud-forecast" id="cloudForecast">
                    <div class="forecast-label">×ª×—×–×™×ª 14:00-00:00 (%):</div>
                    <canvas id="cloudChart" style="width: 100%; height: 150px;"></canvas>
                </div>
                <div class="quality-indicator" id="cloudQuality">--</div>
            </div>

            <!-- Current -->
            <div class="data-card">
                <div class="card-title">
                    <span class="card-icon">ğŸ’§</span>
                    <span>×–×¨××™×</span>
                </div>
                <div class="direction-container">
                    <div class="direction-arrow" id="currentArrow">
                        <svg class="arrow-svg" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                            <defs>
                                <linearGradient id="currentGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                                    <stop offset="0%" style="stop-color:#06b6d4;stop-opacity:1" />
                                    <stop offset="100%" style="stop-color:#0891b2;stop-opacity:1" />
                                </linearGradient>
                            </defs>
                            <g transform="rotate(0 50 50)" id="currentArrowGroup">
                                <path d="M 50 10 L 65 40 L 55 40 L 55 90 L 45 90 L 45 40 L 35 40 Z" 
                                      fill="url(#currentGradient)" 
                                      stroke="#0e7490" 
                                      stroke-width="2"/>
                            </g>
                        </svg>
                    </div>
                    <div class="direction-label" id="currentDirectionLabel">--</div>
                </div>
                <div class="card-content" id="currentData">--</div>
                <div class="card-details" id="currentDetails">×˜×•×¢×Ÿ...</div>
                <div class="quality-indicator" id="currentQuality">--</div>
            </div>
        </div>

        <div class="update-time" id="updateTime">
            ×¢×“×›×•×Ÿ ××—×¨×•×Ÿ: --
        </div>
    </div> <!-- End mainContent container -->

    <script>
        // Password Protection
        const CORRECT_PASSWORD = 'zino';
        const SESSION_KEY = 'harchafnistim_auth';

        function checkPassword() {
            const passwordInput = document.getElementById('passwordInput');
            const loginError = document.getElementById('loginError');
            const password = passwordInput.value;

            if (password === CORRECT_PASSWORD) {
                // Store authentication in session
                sessionStorage.setItem(SESSION_KEY, 'true');
                
                // Hide login overlay
                document.getElementById('loginOverlay').style.display = 'none';
                document.getElementById('mainContent').style.display = 'block';
                
                // Load data
                loadAllData();
            } else {
                // Show error
                loginError.style.display = 'block';
                passwordInput.value = '';
                passwordInput.focus();
                
                // Hide error after 3 seconds
                setTimeout(() => {
                    loginError.style.display = 'none';
                }, 3000);
            }
        }

        function handlePasswordKeypress(event) {
            if (event.key === 'Enter') {
                checkPassword();
            }
        }

        function checkAuthentication() {
            // Check if already authenticated in this session
            if (sessionStorage.getItem(SESSION_KEY) === 'true') {
                document.getElementById('loginOverlay').style.display = 'none';
                document.getElementById('mainContent').style.display = 'block';
                loadAllData();
            } else {
                // Show login screen and focus on password input
                document.getElementById('passwordInput').focus();
            }
        }

        // Run authentication check on page load
        window.addEventListener('DOMContentLoaded', checkAuthentication);

        // Configuration
        const LOCATIONS = {
            'netanya-hadera': {
                lat: 32.4,
                lon: 34.88,
                name: '× ×ª× ×™×”-×—×“×¨×” (×›×œ×œ×™)',
                windguruId: 10172
            },
            'blue-bay': {
                lat: 32.3306,
                lon: 34.8567,
                name: '×‘×œ×• ×‘×™×™',
                windguruId: 10172
            },
            'olga-south': {
                lat: 32.2989,
                lon: 34.8522,
                name: '××•×œ×’×” ×“×¨×•×',
                windguruId: 10172
            },
            'olga-north': {
                lat: 32.3156,
                lon: 34.8545,
                name: '××•×œ×’×” ×¦×¤×•×Ÿ',
                windguruId: 10172
            },
            'argaman': {
                lat: 32.2528,
                lon: 34.8472,
                name: '××¨×’××Ÿ',
                windguruId: 10172
            },
            'rasco': {
                lat: 32.2333,
                lon: 34.8456,
                name: '×¨×¡×§×•',
                windguruId: 10172
            },
            'herzliya-marina': {
                lat: 32.1667,
                lon: 34.8000,
                name: '××¨×™× ×” ×”×¨×¦×œ×™×”',
                windguruId: 2354
            }
        };

        let CONFIG = {
            location: LOCATIONS['netanya-hadera'],
            optimal: {
                wind: { direction: 'E', maxSpeed: 15 },
                waves: { max: 0.5 },
                gps: { interference: 0 },
                moon: { illumination: 20 }, // Under 20% is excellent
                clouds: { min: 70 }, // Over 70% is good for night fishing
                current: { max: 0.3 }
            }
        };

        let currentData = {
            wind: null,
            windForecast: [], // Hourly wind forecast
            waves: null,
            waveForecast: [], // Hourly wave forecast
            gps: null,
            moon: null,
            clouds: null,
            cloudForecast: [], // Hourly cloud forecast
            current: null,
            currentDirection: null, // Add current direction
            sunset: null,
            dusk: null // Last light (civil twilight end)
        };

        // Calculate individual scores
        function calculateWindScore(data) {
            if (!data) return 0;
            let score = 100;
            
            // Wind direction (E is best, W is worst)
            const directions = ['E', 'NE', 'N', 'SE', 'S', 'NW', 'SW', 'W'];
            const dirIndex = directions.indexOf(data.direction);
            if (dirIndex > 0) score -= dirIndex * 5;
            
            // Wind speed (0-15 km/h is best)
            if (data.speed > 15) {
                score -= Math.min((data.speed - 15) * 2, 40);
            }
            
            return Math.max(0, score);
        }

        function calculateWaveScore(height) {
            if (height === null) return 0;
            if (height <= 0.5) return 100;
            if (height <= 1.0) return 70;
            if (height <= 1.5) return 40;
            return Math.max(0, 40 - (height - 1.5) * 20);
        }

        function calculateGPSScore(interference) {
            if (interference === null) return 0;
            return Math.max(0, 100 - interference * 10);
        }

        function calculateMoonScore(illumination, clouds) {
            if (illumination === null) return 0;
            let score = 100;
            
            // Moon illumination (lower is better)
            if (illumination > 20) {
                score -= (illumination - 20) * 1.2;
            }
            
            // Cloud cover can compensate for bright moon
            if (clouds > 70 && illumination > 50) {
                score += 30; // Clouds hiding the moon
            }
            
            return Math.max(0, Math.min(100, score));
        }

        function calculateCloudScore(cover) {
            if (cover === null) return 0;
            // For night fishing, more clouds is better (hides moon)
            if (cover >= 70) return 100;
            if (cover >= 50) return 80;
            if (cover >= 30) return 60;
            return 40;
        }

        function calculateCurrentScore(speed) {
            if (speed === null) return 0;
            if (speed <= 0.3) return 100;
            if (speed <= 0.6) return 70;
            return Math.max(0, 70 - (speed - 0.6) * 50);
        }

        function calculateTotalScore() {
            const scores = {
                wind: calculateWindScore(currentData.wind),
                waves: calculateWaveScore(currentData.waves),
                gps: calculateGPSScore(currentData.gps),
                moon: calculateMoonScore(currentData.moon?.illumination, currentData.clouds),
                clouds: calculateCloudScore(currentData.clouds),
                current: calculateCurrentScore(currentData.current)
            };

            // Weighted average
            // Wind: 30%, Waves: 20%, GPS: 30%
            // Moon, Clouds, Current: 20% total (6.67% each)
            const weights = {
                wind: 0.30,      // 30% - Critical for drone control
                waves: 0.20,     // 20% - Important for line stability
                gps: 0.30,       // 30% - Critical for drone navigation
                moon: 0.0667,    // 6.67% - Affects fish behavior
                clouds: 0.0667,  // 6.67% - Moderates moon effect
                current: 0.0666  // 6.66% - Minor impact (rounds to 100%)
            };

            const total = Object.keys(scores).reduce((sum, key) => {
                return sum + (scores[key] * weights[key]);
            }, 0);

            return Math.round(total);
        }

        function getStatusText(score) {
            if (score >= 85) return 'ğŸ¯ ××¢×•×œ×” - ×–××Ÿ ××•×©×œ× ×œ×“×™×’!';
            if (score >= 70) return 'âœ… ×˜×•×‘ ×××•×“ - ×ª× ××™× × ×•×—×™×';
            if (score >= 55) return 'ğŸ‘ ×‘×¡×“×¨ - × ×™×ª×Ÿ ×œ×“×•×’';
            if (score >= 40) return 'âš ï¸ ×‘×™× ×•× ×™ - ×ª× ××™× ×××ª×’×¨×™×';
            return 'âŒ ×œ× ××•××œ×¥ - ×ª× ××™× ×§×©×™×';
        }

        function getQualityClass(score) {
            if (score >= 80) return 'excellent';
            if (score >= 60) return 'good';
            if (score >= 40) return 'moderate';
            return 'poor';
        }

        function getQualityText(score) {
            if (score >= 80) return '××¦×•×™×Ÿ';
            if (score >= 60) return '×˜×•×‘';
            if (score >= 40) return '×‘×™× ×•× ×™';
            return '×’×¨×•×¢';
        }

        function getMoonIcon(phase) {
            const icons = {
                'new': 'ğŸŒ‘',
                'waxing_crescent': 'ğŸŒ’',
                'first_quarter': 'ğŸŒ“',
                'waxing_gibbous': 'ğŸŒ”',
                'full': 'ğŸŒ•',
                'waning_gibbous': 'ğŸŒ–',
                'last_quarter': 'ğŸŒ—',
                'waning_crescent': 'ğŸŒ˜'
            };
            return icons[phase] || 'ğŸŒ™';
        }

        function updateMoonVisual(illumination) {
            // illumination is 0-100
            const moonShadow = document.getElementById('moonShadow');
            const moonBase = document.getElementById('moonBase');
            if (!moonShadow || !moonBase) return;
            
            // Calculate the moon phase visualization
            // We'll create a proper moon phase using an ellipse shadow
            const phase = illumination / 100; // Convert to 0-1
            
            if (phase <= 0.02) {
                // New Moon - fully dark
                moonShadow.setAttribute('rx', '45');
                moonShadow.setAttribute('ry', '45');
                moonShadow.setAttribute('transform', 'translate(0,0)');
                moonBase.setAttribute('fill', '#2a2a3e');
            } else if (phase < 0.5) {
                // Waxing Crescent to First Quarter (0-50%)
                // Right side is illuminated, shadow on left
                moonBase.setAttribute('fill', '#f0f0f0');
                const shadowWidth = 45 * (1 - phase * 2); // Goes from 45 to 0
                moonShadow.setAttribute('rx', shadowWidth);
                moonShadow.setAttribute('ry', '45');
                moonShadow.setAttribute('transform', `translate(${-shadowWidth},0)`);
            } else if (phase < 0.98) {
                // Waxing Gibbous to Full Moon (50-98%)
                // Left side shadow shrinks
                moonBase.setAttribute('fill', '#f0f0f0');
                const shadowWidth = 45 * ((1 - phase) * 2); // Goes from 0 to 45
                moonShadow.setAttribute('rx', shadowWidth);
                moonShadow.setAttribute('ry', '45');
                moonShadow.setAttribute('transform', `translate(${45 - shadowWidth},0)`);
            } else {
                // Full Moon (98-100%) - almost no shadow
                moonBase.setAttribute('fill', '#f0f0f0');
                moonShadow.setAttribute('rx', '0');
                moonShadow.setAttribute('ry', '45');
                moonShadow.setAttribute('transform', 'translate(50,0)');
            }
            
            // Add glow effect for fuller moons
            if (phase > 0.7) {
                moonBase.style.filter = `drop-shadow(0 0 ${phase * 10}px rgba(255,255,255,0.8))`;
            } else {
                moonBase.style.filter = 'none';
            }
        }

        function getMoonPhaseName(illumination) {
            if (illumination < 3) return '×™×¨×— ×—×“×© (××•×œ×“)';
            if (illumination < 25) return '×”×™×œ×” ×¦×¢×™×¨×”';
            if (illumination < 48) return '×¨×‘×¢ ×¨××©×•×Ÿ';
            if (illumination < 52) return '×—×¦×™ ×™×¨×—';
            if (illumination < 75) return '×’×™×‘×Ÿ ×’×“×œ';
            if (illumination < 97) return '×›××¢×˜ ××œ×';
            return '×™×¨×— ××œ×';
        }

        function getWindDirection(deg) {
            const directions = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
            const index = Math.round(deg / 45) % 8;
            return directions[index];
        }

        function getDirectionHebrew(direction) {
            const hebrewDirections = {
                'N': '×¦×¤×•×Ÿ',
                'NE': '×¦×¤×•×Ÿ-××–×¨×—',
                'E': '××–×¨×—',
                'SE': '×“×¨×•×-××–×¨×—',
                'S': '×“×¨×•×',
                'SW': '×“×¨×•×-××¢×¨×‘',
                'W': '××¢×¨×‘',
                'NW': '×¦×¤×•×Ÿ-××¢×¨×‘'
            };
            return hebrewDirections[direction] || direction;
        }

        function updateArrowRotation(elementId, degrees) {
            // Meteorological convention: arrows point FROM the direction wind/current comes from
            // So we need to add 180 degrees to show where it's coming from
            // North wind (0Â°) should point down (180Â°)
            // East wind (90Â°) should point left (270Â°)
            // South wind (180Â°) should point up (0Â°)
            // West wind (270Â°) should point right (90Â°)
            const arrowGroup = document.querySelector(`#${elementId} g`);
            if (arrowGroup) {
                const displayDegrees = (degrees + 180) % 360;
                arrowGroup.setAttribute('transform', `rotate(${displayDegrees} 50 50)`);
            }
        }

        // Fetch weather data from Open-Meteo and marine data
        async function fetchWeatherData() {
            try {
                // Fetch basic weather data with hourly forecast
                const weatherUrl = `https://api.open-meteo.com/v1/forecast?latitude=${CONFIG.location.lat}&longitude=${CONFIG.location.lon}&current=temperature_2m,relative_humidity_2m,precipitation,cloud_cover,wind_speed_10m,wind_direction_10m&hourly=wind_speed_10m,wind_direction_10m,cloud_cover&daily=sunset,sunrise&timezone=Asia/Jerusalem&forecast_days=2`;
                
                const weatherResponse = await fetch(weatherUrl);
                const weatherData = await weatherResponse.json();
                
                // Current wind data
                const windSpeed = Math.round(weatherData.current.wind_speed_10m);
                const windDir = getWindDirection(weatherData.current.wind_direction_10m);
                currentData.wind = {
                    speed: windSpeed,
                    direction: windDir,
                    degrees: weatherData.current.wind_direction_10m
                };
                
                // Process hourly forecast for 14:00 to 00:00
                if (weatherData.hourly && weatherData.hourly.time) {
                    const now = new Date();
                    const today = now.toISOString().split('T')[0]; // YYYY-MM-DD
                    const tomorrow = new Date(now.getTime() + 24*60*60*1000).toISOString().split('T')[0];
                    
                    currentData.windForecast = [];
                    currentData.cloudForecast = [];
                    
                    for (let i = 0; i < weatherData.hourly.time.length; i++) {
                        const forecastTime = new Date(weatherData.hourly.time[i]);
                        const forecastHour = forecastTime.getHours();
                        const forecastDate = forecastTime.toISOString().split('T')[0];
                        
                        // Include hours 14:00-23:00 today, and 00:00 from tomorrow
                        if ((forecastDate === today && forecastHour >= 14 && forecastHour <= 23) ||
                            (forecastDate === tomorrow && forecastHour === 0)) {
                            
                            // Wind forecast
                            currentData.windForecast.push({
                                time: forecastTime,
                                hour: forecastHour,
                                speed: Math.round(weatherData.hourly.wind_speed_10m[i]),
                                direction: getWindDirection(weatherData.hourly.wind_direction_10m[i]),
                                degrees: weatherData.hourly.wind_direction_10m[i]
                            });
                            
                            // Cloud forecast
                            currentData.cloudForecast.push({
                                time: forecastTime,
                                hour: forecastHour,
                                cover: weatherData.hourly.cloud_cover[i] || 0
                            });
                        }
                    }
                }
                
                // Cloud cover
                currentData.clouds = weatherData.current.cloud_cover;
                
                // Sunset and twilight data
                if (weatherData.daily && weatherData.daily.sunset && weatherData.daily.sunset[0]) {
                    currentData.sunset = new Date(weatherData.daily.sunset[0]);
                    // Calculate civil twilight end (about 30 minutes after sunset)
                    currentData.dusk = new Date(currentData.sunset.getTime() + 30 * 60000);
                }
                
                // Fetch marine data for waves with hourly forecast
                const marineUrl = `https://marine-api.open-meteo.com/v1/marine?latitude=${CONFIG.location.lat}&longitude=${CONFIG.location.lon}&current=wave_height,ocean_current_velocity,ocean_current_direction&hourly=wave_height&timezone=Asia/Jerusalem&forecast_days=2`;
                
                try {
                    const marineResponse = await fetch(marineUrl);
                    const marineData = await marineResponse.json();
                    
                    // Current wave height
                    currentData.waves = marineData.current?.wave_height || 0.3;
                    
                    // Current speed
                    currentData.current = marineData.current?.ocean_current_velocity || 0.2;
                    
                    // Current direction
                    currentData.currentDirection = marineData.current?.ocean_current_direction || 180;
                    
                    // Process hourly wave forecast for 14:00 to 00:00
                    if (marineData.hourly && marineData.hourly.time) {
                        const now = new Date();
                        const today = now.toISOString().split('T')[0]; // YYYY-MM-DD
                        const tomorrow = new Date(now.getTime() + 24*60*60*1000).toISOString().split('T')[0];
                        
                        currentData.waveForecast = [];
                        
                        for (let i = 0; i < marineData.hourly.time.length; i++) {
                            const forecastTime = new Date(marineData.hourly.time[i]);
                            const forecastHour = forecastTime.getHours();
                            const forecastDate = forecastTime.toISOString().split('T')[0];
                            
                            // Include hours 14:00-23:00 today, and 00:00 from tomorrow
                            if ((forecastDate === today && forecastHour >= 14 && forecastHour <= 23) ||
                                (forecastDate === tomorrow && forecastHour === 0)) {
                                
                                currentData.waveForecast.push({
                                    time: forecastTime,
                                    hour: forecastHour,
                                    height: marineData.hourly.wave_height[i] || 0
                                });
                            }
                        }
                    }
                    
                } catch (marineError) {
                    console.warn('Marine data unavailable, using estimates:', marineError);
                    currentData.waves = 0.4;
                    currentData.current = 0.2;
                    currentData.currentDirection = 180; // Default south
                    currentData.waveForecast = [];
                }
                
                updateWeatherUI();
                updateWindForecastUI();
                updateWaveForecastUI();
                updateCloudForecastUI();
                updateSunTimesUI();
                
            } catch (error) {
                console.error('Error fetching weather data:', error);
                document.getElementById('windDetails').innerHTML = '<div class="error">×©×’×™××” ×‘×˜×¢×™× ×ª × ×ª×•× ×™ ××–×’ ××•×•×™×¨</div>';
            }
        }

        // Optional: Fetch from Windguru (requires user to set up spot ID)
        // Note: Direct access may be blocked by CORS. For personal use only.
        async function fetchWindguruData(spotId = 10172) {
            // Windguru Netanya spot ID: 10172
            // This function is provided for educational purposes
            // Windguru's TOS prohibits automated scraping for commercial use
            
            try {
                // This would require a CORS proxy or backend server
                // Example implementation left commented for reference
                
                /*
                const proxyUrl = 'https://api.allorigins.win/raw?url=';
                const windguruUrl = `https://www.windguru.cz/int/iapi.php?q=forecast&id_spot=${spotId}`;
                
                const response = await fetch(proxyUrl + encodeURIComponent(windguruUrl));
                const data = await response.json();
                
                if (data && data.fcst) {
                    // Parse Windguru forecast data
                    const currentHour = new Date().getHours();
                    const forecast = data.fcst[Object.keys(data.fcst)[0]]; // Get first model
                    
                    // Find closest hour
                    let closestIndex = 0;
                    for (let i = 0; i < forecast.hours.length; i++) {
                        if (Math.abs(forecast.hours[i] - currentHour) < Math.abs(forecast.hours[closestIndex] - currentHour)) {
                            closestIndex = i;
                        }
                    }
                    
                    currentData.wind = {
                        speed: forecast.wind_speed[closestIndex],
                        direction: getWindDirection(forecast.wind_direction[closestIndex]),
                        degrees: forecast.wind_direction[closestIndex]
                    };
                    
                    updateWeatherUI();
                }
                */
                
                console.log('Windguru integration disabled. Using Open-Meteo data instead.');
                console.log('To check Windguru manually, visit: https://www.windguru.cz/' + spotId);
                
            } catch (error) {
                console.error('Windguru fetch error:', error);
            }
        }

        // Fetch moon phase data
        async function fetchMoonData() {
            try {
                const now = new Date();
                const url = `https://api.farmsense.net/v1/moonphases/?d=${now.getDate()}&m=${now.getMonth() + 1}&y=${now.getFullYear()}`;
                
                const response = await fetch(url);
                const data = await response.json();
                
                if (data && data[0]) {
                    const moonData = data[0];
                    currentData.moon = {
                        phase: moonData.Phase,
                        illumination: Math.round(moonData.Illumination * 100)
                    };
                }
                
                updateMoonUI();
                
            } catch (error) {
                console.error('Error fetching moon data:', error);
                // Fallback calculation
                calculateMoonPhase();
            }
        }

        // Fallback moon calculation
        function calculateMoonPhase() {
            const now = new Date();
            const year = now.getFullYear();
            const month = now.getMonth() + 1;
            const day = now.getDate();
            
            // Simplified moon phase calculation
            const c = (year - 2000) / 100;
            const e = 23.4393 - 0.0130 * c;
            const L = 280.466 + 36000.770 * c;
            const M = 357.529 + 35999.050 * c;
            
            const phase = ((now - new Date(2000, 0, 6)) / (29.53 * 24 * 60 * 60 * 1000)) % 1;
            const illumination = Math.round((1 - Math.cos(phase * 2 * Math.PI)) * 50);
            
            currentData.moon = {
                phase: phase < 0.25 ? 'waxing_crescent' : phase < 0.5 ? 'first_quarter' : phase < 0.75 ? 'waning_gibbous' : 'waning_crescent',
                illumination: illumination
            };
            
            updateMoonUI();
        }

        // Simulate GPS interference (you'll need to integrate real data from FlightRadar24)
        async function fetchGPSData() {
            try {
                // This would require scraping FlightRadar24 or using their API
                // For now, using a placeholder
                currentData.gps = Math.floor(Math.random() * 3); // 0-10 scale
                
                updateGPSUI();
                
            } catch (error) {
                console.error('Error fetching GPS data:', error);
                currentData.gps = 0; // Assume no interference if can't fetch
                updateGPSUI();
            }
        }

        // Update UI functions
        function updateWeatherUI() {
            if (currentData.wind) {
                const windScore = calculateWindScore(currentData.wind);
                document.getElementById('windData').textContent = `${currentData.wind.speed} km/h`;
                document.getElementById('windDetails').textContent = `×›×™×•×•×Ÿ: ${getDirectionHebrew(currentData.wind.direction)} (${currentData.wind.degrees}Â°)`;
                document.getElementById('windQuality').textContent = getQualityText(windScore);
                document.getElementById('windQuality').className = `quality-indicator ${getQualityClass(windScore)}`;
                
                // Update wind arrow
                updateArrowRotation('windArrowGroup', currentData.wind.degrees);
                document.getElementById('windDirectionLabel').textContent = getDirectionHebrew(currentData.wind.direction);
            }
            
            if (currentData.waves !== null) {
                const waveScore = calculateWaveScore(currentData.waves);
                document.getElementById('waveData').textContent = `${currentData.waves.toFixed(2)} ××˜×¨`;
                document.getElementById('waveDetails').textContent = currentData.waves <= 0.5 ? '×’×œ×™× × ××•×›×™× - ××¦×•×™×Ÿ' : currentData.waves <= 1 ? '×’×œ×™× ×‘×™× ×•× ×™×™×' : '×’×œ×™× ×’×‘×•×”×™×';
                document.getElementById('waveQuality').textContent = getQualityText(waveScore);
                document.getElementById('waveQuality').className = `quality-indicator ${getQualityClass(waveScore)}`;
            }
            
            if (currentData.clouds !== null) {
                const cloudScore = calculateCloudScore(currentData.clouds);
                document.getElementById('cloudData').textContent = `${currentData.clouds}%`;
                document.getElementById('cloudDetails').textContent = currentData.clouds > 70 ? '××¢×•× ×Ÿ - ×˜×•×‘ ×œ×“×™×’ ×œ×™×œ×”' : currentData.clouds > 30 ? '×—×œ×§×™×ª ××¢×•× ×Ÿ' : '×©××™×™× ×‘×”×™×¨×™×';
                document.getElementById('cloudQuality').textContent = getQualityText(cloudScore);
                document.getElementById('cloudQuality').className = `quality-indicator ${getQualityClass(cloudScore)}`;
            }
            
            if (currentData.current !== null) {
                const currentScore = calculateCurrentScore(currentData.current);
                document.getElementById('currentData').textContent = `${currentData.current.toFixed(2)} m/s`;
                
                // Update current direction display
                if (currentData.currentDirection !== null) {
                    const currentDir = getWindDirection(currentData.currentDirection);
                    document.getElementById('currentDetails').textContent = `×›×™×•×•×Ÿ: ${getDirectionHebrew(currentDir)} | ` + 
                        (currentData.current <= 0.3 ? '×–×¨× ×—×œ×© - ××¦×•×™×Ÿ' : currentData.current <= 0.6 ? '×–×¨× ×‘×™× ×•× ×™' : '×–×¨× ×—×–×§');
                    
                    // Update current arrow
                    updateArrowRotation('currentArrowGroup', currentData.currentDirection);
                    document.getElementById('currentDirectionLabel').textContent = getDirectionHebrew(currentDir);
                } else {
                    document.getElementById('currentDetails').textContent = currentData.current <= 0.3 ? '×–×¨× ×—×œ×© - ××¦×•×™×Ÿ' : currentData.current <= 0.6 ? '×–×¨× ×‘×™× ×•× ×™' : '×–×¨× ×—×–×§';
                }
                
                document.getElementById('currentQuality').textContent = getQualityText(currentScore);
                document.getElementById('currentQuality').className = `quality-indicator ${getQualityClass(currentScore)}`;
            }
        }

        function updateMoonUI() {
            if (currentData.moon) {
                const moonScore = calculateMoonScore(currentData.moon.illumination, currentData.clouds);
                const phaseName = getMoonPhaseName(currentData.moon.illumination);
                
                // Update visual moon phase
                updateMoonVisual(currentData.moon.illumination);
                
                document.getElementById('moonData').textContent = `${currentData.moon.illumination}% ××•××¨`;
                document.getElementById('moonDetails').innerHTML = `${phaseName}<br>` + 
                    (currentData.moon.illumination < 20 ? '×ª× ××™× ××¦×•×™× ×™× ×œ×“×™×’' : 
                     currentData.moon.illumination > 80 ? '××•×¨ ×—×–×§ - ×¤×—×•×ª ××•××œ×¥' : 
                     '×ª× ××™ ××•×¨ ×‘×™× ×•× ×™×™×');
                document.getElementById('moonQuality').textContent = getQualityText(moonScore);
                document.getElementById('moonQuality').className = `quality-indicator ${getQualityClass(moonScore)}`;
            }
        }

        function updateSunTimesUI() {
            if (currentData.sunset) {
                const sunsetStr = currentData.sunset.toLocaleTimeString('he-IL', { 
                    hour: '2-digit', 
                    minute: '2-digit',
                    hour12: false
                });
                document.getElementById('sunsetTime').textContent = `×©×§×™×¢×”: ${sunsetStr}`;
            }
            
            if (currentData.dusk) {
                const duskStr = currentData.dusk.toLocaleTimeString('he-IL', { 
                    hour: '2-digit', 
                    minute: '2-digit',
                    hour12: false
                });
                document.getElementById('duskTime').textContent = `×¡×•×£ ×“××“×•××™×: ${duskStr}`;
            }
        }

        function updateWindForecastUI() {
            const canvas = document.getElementById('windChart');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            
            // Set canvas size properly
            const container = canvas.parentElement;
            canvas.width = container.offsetWidth;
            canvas.height = 150;
            
            if (currentData.windForecast.length === 0) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('××™×Ÿ × ×ª×•× ×™ ×ª×—×–×™×ª', canvas.width / 2, canvas.height / 2);
                return;
            }
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Data
            const hours = currentData.windForecast.map(f => f.hour.toString().padStart(2, '0') + ':00');
            const speeds = currentData.windForecast.map(f => f.speed);
            const maxSpeed = Math.max(...speeds, 30);
            const minSpeed = 0;
            
            // Chart dimensions
            const padding = { top: 20, right: 20, bottom: 30, left: 40 };
            const chartWidth = canvas.width - padding.left - padding.right;
            const chartHeight = canvas.height - padding.top - padding.bottom;
            
            // Draw grid lines and Y-axis labels
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.font = '11px Arial';
            ctx.lineWidth = 1;
            
            for (let i = 0; i <= 4; i++) {
                const y = padding.top + (chartHeight / 4) * i;
                const value = Math.round(maxSpeed - (maxSpeed / 4) * i);
                
                // Grid line
                ctx.beginPath();
                ctx.moveTo(padding.left, y);
                ctx.lineTo(padding.left + chartWidth, y);
                ctx.stroke();
                
                // Y-axis label
                ctx.textAlign = 'right';
                ctx.fillText(value, padding.left - 5, y + 4);
            }
            
            // Draw reference line at 15 km/h (optimal threshold)
            const optimalY = padding.top + chartHeight - ((15 / maxSpeed) * chartHeight);
            ctx.strokeStyle = 'rgba(16, 185, 129, 0.5)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(padding.left, optimalY);
            ctx.lineTo(padding.left + chartWidth, optimalY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw line chart
            const stepX = chartWidth / (speeds.length - 1);
            
            // Create gradient for area under curve
            const gradient = ctx.createLinearGradient(0, padding.top, 0, padding.top + chartHeight);
            gradient.addColorStop(0, 'rgba(96, 165, 250, 0.4)');
            gradient.addColorStop(1, 'rgba(96, 165, 250, 0.05)');
            
            // Draw filled area
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.moveTo(padding.left, padding.top + chartHeight);
            
            speeds.forEach((speed, index) => {
                const x = padding.left + stepX * index;
                const y = padding.top + chartHeight - ((speed / maxSpeed) * chartHeight);
                if (index === 0) {
                    ctx.lineTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            
            ctx.lineTo(padding.left + chartWidth, padding.top + chartHeight);
            ctx.closePath();
            ctx.fill();
            
            // Draw line
            ctx.strokeStyle = '#60a5fa';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            speeds.forEach((speed, index) => {
                const x = padding.left + stepX * index;
                const y = padding.top + chartHeight - ((speed / maxSpeed) * chartHeight);
                
                if (index === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            
            ctx.stroke();
            
            // Draw points
            speeds.forEach((speed, index) => {
                const x = padding.left + stepX * index;
                const y = padding.top + chartHeight - ((speed / maxSpeed) * chartHeight);
                
                // Determine color based on speed
                let color = '#10b981'; // Good
                if (speed > 25) color = '#ef4444'; // Poor
                else if (speed > 15) color = '#f59e0b'; // Moderate
                
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw value above point
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.font = 'bold 11px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(speed, x, y - 8);
            });
            
            // Draw X-axis labels
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            
            hours.forEach((hour, index) => {
                const x = padding.left + stepX * index;
                // Show every other label to avoid crowding
                if (index % 2 === 0 || hours.length <= 6) {
                    ctx.fillText(hour, x, canvas.height - 5);
                }
            });
        }

        function updateWaveForecastUI() {
            const canvas = document.getElementById('waveChart');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            
            // Set canvas size properly
            const container = canvas.parentElement;
            canvas.width = container.offsetWidth;
            canvas.height = 150;
            
            if (currentData.waveForecast.length === 0) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('××™×Ÿ × ×ª×•× ×™ ×ª×—×–×™×ª', canvas.width / 2, canvas.height / 2);
                return;
            }
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Data
            const hours = currentData.waveForecast.map(f => f.hour.toString().padStart(2, '0') + ':00');
            const heights = currentData.waveForecast.map(f => f.height);
            const maxHeight = Math.max(...heights, 2);
            const minHeight = 0;
            
            // Chart dimensions
            const padding = { top: 20, right: 20, bottom: 30, left: 40 };
            const chartWidth = canvas.width - padding.left - padding.right;
            const chartHeight = canvas.height - padding.top - padding.bottom;
            
            // Draw grid lines and Y-axis labels
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.font = '11px Arial';
            ctx.lineWidth = 1;
            
            for (let i = 0; i <= 4; i++) {
                const y = padding.top + (chartHeight / 4) * i;
                const value = (maxHeight - (maxHeight / 4) * i).toFixed(1);
                
                // Grid line
                ctx.beginPath();
                ctx.moveTo(padding.left, y);
                ctx.lineTo(padding.left + chartWidth, y);
                ctx.stroke();
                
                // Y-axis label
                ctx.textAlign = 'right';
                ctx.fillText(value + 'm', padding.left - 5, y + 4);
            }
            
            // Draw reference line at 0.5m (optimal threshold)
            const optimalY = padding.top + chartHeight - ((0.5 / maxHeight) * chartHeight);
            ctx.strokeStyle = 'rgba(16, 185, 129, 0.5)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(padding.left, optimalY);
            ctx.lineTo(padding.left + chartWidth, optimalY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw line chart
            const stepX = chartWidth / (heights.length - 1);
            
            // Create gradient for area under curve
            const gradient = ctx.createLinearGradient(0, padding.top, 0, padding.top + chartHeight);
            gradient.addColorStop(0, 'rgba(6, 182, 212, 0.4)');
            gradient.addColorStop(1, 'rgba(6, 182, 212, 0.05)');
            
            // Draw filled area
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.moveTo(padding.left, padding.top + chartHeight);
            
            heights.forEach((height, index) => {
                const x = padding.left + stepX * index;
                const y = padding.top + chartHeight - ((height / maxHeight) * chartHeight);
                if (index === 0) {
                    ctx.lineTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            
            ctx.lineTo(padding.left + chartWidth, padding.top + chartHeight);
            ctx.closePath();
            ctx.fill();
            
            // Draw line
            ctx.strokeStyle = '#06b6d4';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            heights.forEach((height, index) => {
                const x = padding.left + stepX * index;
                const y = padding.top + chartHeight - ((height / maxHeight) * chartHeight);
                
                if (index === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            
            ctx.stroke();
            
            // Draw points
            heights.forEach((height, index) => {
                const x = padding.left + stepX * index;
                const y = padding.top + chartHeight - ((height / maxHeight) * chartHeight);
                
                // Determine color based on height
                let color = '#10b981'; // Good
                if (height > 1.0) color = '#ef4444'; // Poor
                else if (height > 0.5) color = '#f59e0b'; // Moderate
                
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw value above point
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.font = 'bold 11px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(height.toFixed(2), x, y - 8);
            });
            
            // Draw X-axis labels
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            
            hours.forEach((hour, index) => {
                const x = padding.left + stepX * index;
                // Show every other label to avoid crowding
                if (index % 2 === 0 || hours.length <= 6) {
                    ctx.fillText(hour, x, canvas.height - 5);
                }
            });
        }

        function updateGPSUI() {
            if (currentData.gps !== null) {
                const gpsScore = calculateGPSScore(currentData.gps);
                document.getElementById('gpsData').textContent = currentData.gps === 0 ? '××™×Ÿ ×”×¤×¨×¢×•×ª' : `×¨××” ${currentData.gps}/10`;
                document.getElementById('gpsDetails').textContent = currentData.gps === 0 ? 'GPS ×¤×•×¢×œ ×ª×§×™×Ÿ' : currentData.gps < 5 ? '×”×¤×¨×¢×•×ª ×§×œ×•×ª' : '×”×¤×¨×¢×•×ª ××©××¢×•×ª×™×•×ª';
                document.getElementById('gpsQuality').textContent = getQualityText(gpsScore);
                document.getElementById('gpsQuality').className = `quality-indicator ${getQualityClass(gpsScore)}`;
            }
        }

        function updateTotalScore() {
            const score = calculateTotalScore();
            document.getElementById('totalScore').textContent = score;
            document.getElementById('statusText').textContent = getStatusText(score);
            
            // Update score container color based on score
            const container = document.querySelector('.score-container');
            if (score >= 85) {
                container.style.background = 'linear-gradient(135deg, #10b981 0%, #059669 100%)';
            } else if (score >= 70) {
                container.style.background = 'linear-gradient(135deg, #3b82f6 0%, #2563eb 100%)';
            } else if (score >= 55) {
                container.style.background = 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)';
            } else {
                container.style.background = 'linear-gradient(135deg, #ef4444 0%, #dc2626 100%)';
            }
        }

        async function loadAllData() {
            document.getElementById('statusText').textContent = '×˜×•×¢×Ÿ × ×ª×•× ×™×...';
            
            await Promise.all([
                fetchWeatherData(),
                fetchMoonData(),
                fetchGPSData()
            ]);
            
            updateTotalScore();
            
            const now = new Date();
            document.getElementById('updateTime').textContent = `×¢×“×›×•×Ÿ ××—×¨×•×Ÿ: ${now.toLocaleString('he-IL')}`;
        }

        function changeLocation() {
            const selectElement = document.getElementById('locationSelect');
            const selectedLocationKey = selectElement.value;
            
            // Update CONFIG with new location
            CONFIG.location = LOCATIONS[selectedLocationKey];
            
            // Update location info display
            updateLocationInfo();
            
            // Reload all data for new location
            loadAllData();
        }

        function updateLocationInfo() {
            const locationInfo = document.querySelector('.location-info strong');
            if (locationInfo) {
                locationInfo.textContent = `ğŸ“ ××–×•×¨: ${CONFIG.location.name}`;
            }
            
            // Update Windguru links based on location
            const windguruLinks = document.querySelector('.location-info div');
            if (windguruLinks && CONFIG.location.windguruId) {
                windguruLinks.innerHTML = `
                    <strong>ğŸŒŠ ×§×™×©×•×¨ ×œ×•×•×™× ×“×’×•×¨×•:</strong><br>
                    <a href="https://www.windguru.cz/${CONFIG.location.windguruId}" target="_blank" style="color: #ffd700; text-decoration: none;">${CONFIG.location.name} â†—</a>
                `;
            }
        }

        // Auto-refresh every 10 minutes (only when authenticated)
        setInterval(() => {
            if (sessionStorage.getItem(SESSION_KEY) === 'true') {
                loadAllData();
            }
        }, 10 * 60 * 1000);

        function updateCloudForecastUI() {
            const canvas = document.getElementById('cloudChart');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            
            // Set canvas size properly
            const container = canvas.parentElement;
            canvas.width = container.offsetWidth;
            canvas.height = 150;
            
            if (currentData.cloudForecast.length === 0) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('××™×Ÿ × ×ª×•× ×™ ×ª×—×–×™×ª', canvas.width / 2, canvas.height / 2);
                return;
            }
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Data
            const hours = currentData.cloudForecast.map(f => f.hour.toString().padStart(2, '0') + ':00');
            const covers = currentData.cloudForecast.map(f => f.cover);
            
            // Chart dimensions
            const padding = { top: 20, right: 20, bottom: 30, left: 40 };
            const chartWidth = canvas.width - padding.left - padding.right;
            const chartHeight = canvas.height - padding.top - padding.bottom;
            
            // Draw grid lines and Y-axis labels
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.font = '11px Arial';
            ctx.lineWidth = 1;
            
            for (let i = 0; i <= 4; i++) {
                const y = padding.top + (chartHeight / 4) * i;
                const value = Math.round(100 - (100 / 4) * i);
                
                // Grid line
                ctx.beginPath();
                ctx.moveTo(padding.left, y);
                ctx.lineTo(padding.left + chartWidth, y);
                ctx.stroke();
                
                // Y-axis label
                ctx.textAlign = 'right';
                ctx.fillText(value + '%', padding.left - 5, y + 4);
            }
            
            // Draw reference line at 70% (good threshold for night fishing - clouds hide moon)
            const goodThresholdY = padding.top + chartHeight - ((70 / 100) * chartHeight);
            ctx.strokeStyle = 'rgba(16, 185, 129, 0.5)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(padding.left, goodThresholdY);
            ctx.lineTo(padding.left + chartWidth, goodThresholdY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw line chart
            const stepX = chartWidth / (covers.length - 1);
            
            // Create gradient for area under curve
            const gradient = ctx.createLinearGradient(0, padding.top, 0, padding.top + chartHeight);
            gradient.addColorStop(0, 'rgba(148, 163, 184, 0.4)');
            gradient.addColorStop(1, 'rgba(148, 163, 184, 0.05)');
            
            // Draw filled area
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.moveTo(padding.left, padding.top + chartHeight);
            
            covers.forEach((cover, index) => {
                const x = padding.left + stepX * index;
                const y = padding.top + chartHeight - ((cover / 100) * chartHeight);
                ctx.lineTo(x, y);
            });
            
            ctx.lineTo(padding.left + chartWidth, padding.top + chartHeight);
            ctx.closePath();
            ctx.fill();
            
            // Draw line
            ctx.strokeStyle = '#94a3b8';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            covers.forEach((cover, index) => {
                const x = padding.left + stepX * index;
                const y = padding.top + chartHeight - ((cover / 100) * chartHeight);
                
                if (index === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            
            ctx.stroke();
            
            // Draw points
            covers.forEach((cover, index) => {
                const x = padding.left + stepX * index;
                const y = padding.top + chartHeight - ((cover / 100) * chartHeight);
                
                // Determine color based on cover (for night fishing, more clouds is better)
                let color = '#10b981'; // Good (high clouds at night hide moon)
                if (cover < 30) color = '#ef4444'; // Poor (clear sky = bright moon)
                else if (cover < 70) color = '#f59e0b'; // Moderate
                
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw value above point
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.font = 'bold 11px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(Math.round(cover) + '%', x, y - 8);
            });
            
            // Draw X-axis labels
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            
            hours.forEach((hour, index) => {
                const x = padding.left + stepX * index;
                // Show every other label to avoid crowding
                if (index % 2 === 0 || hours.length <= 6) {
                    ctx.fillText(hour, x, canvas.height - 5);
                }
            });
        }

        // Chart instances
        let windChart = null;
        let waveChart = null;
    </script>
</body>
</html>
